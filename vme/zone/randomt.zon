/*
filename    random
password    2kpwd
changedby   Papi
EmailAdd    Papi  <seifert@dikumud.com>
request     compile
version     1
END HEADER*/

#include <macros.h>


%zone		        randomt

lifespan 25
reset RESET_ANYHOW

creators {"papi"}

notes
"This zone is an attempt to make random treasure by Papi."


help
"Player should never be in here."


#define Q(x) #x
#define QUOTE(x) Q(x)

%dil

dilbegin identify(u :unitptr, norm : string, improved: string);
var
    exd : extraptr;
code
{
    if (norm != "")
    {
        exd := "$identify" in u.extra;
        if (exd == null)
        {
            addextra(u.extra, {"$identify"}, "");
            exd := "$identify" in u.extra;
        }

        exd.descr := exd.descr + norm + "<br/>";
    }

    if (improved != "")
    {
        exd := "$improved identify" in u.extra;
        if (exd == null)
        {
            addextra(u.extra, {"$improved identify"}, "");
            exd := "$improved identify" in u.extra;
        }

        exd.descr := exd.descr + improved + "<br/>";
    }

    return;
}
dilend


dilbegin string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var
   vowels : string;
   ana : string;
code
{
    vowels := "aeiou";

    if (a1 != "")
    {
        s := replace("$1n", a1, s);

        if (a1.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$1a", ana, s);
    }

    if (a2 != "")
    {
        s := replace("$2n", a2, s);

        if (a2.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$2a", ana, s);
    }

    if (a3 != "")
    {
        s := replace("$3n", a3, s);

        if (a3.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$3a", ana, s);
    }

    if (a4 != "")
    {
        s := replace("$4n", a4, s);

        if (a4.[0] in vowels)
            ana := "an";
        else
            ana := "a";

        s := replace("$4a", ana, s);
    }

    return (s);
}
dilend


dilbegin integer minmax7(i : integer);
code
{
    if (i > 7)
        return (7);

    if (i < -7)
        return (-7);

    return (i);
}
dilend



// il : intlist  [array of integers from 5..94]
//
// This function presume rolls of < 5 are a failure, each -50 is -1 more
// This function presume rolls of > 95 are a open-ended success, each +50 is +1 more
// The integers in the intlist are the number of bonuses, in the range
// 5..94 
//
// Example: {15,75,90}
//  Roll <= -50     = -2
//  Roll [-49..4]   = -1
//  Roll [ 5..15]   =  0
//  Roll [16..75]   = +1
//  Roll [76..90]   = +2
//  Roll [91..141]  = +3
//  Roll [142..192] = +4
//
// The first intlist entry must be > 4
//
dilbegin integer successroll_oe(il : intlist, rollskew : integer);
var
    roll : integer;
    j : integer;
    m : integer;
code
{
    roll := openroll(100, 5) + rollskew;
    
    // Test if failure
    if (roll <= 4)
    {
        if (roll > -50)
            return (-1);
        else
            return ((roll / 50)-1);
    }

    j := 0;
    m := length(il);

    if (m < 1)
    {
        log("Illegal intlist in successroll_oe()");
        quit;
    }

    while (j < m)
    {
        if (roll <= il.[j])
            break;
        j := j + 1;
    }

    if (j < m)
        return (j); // First match = 0, second = +1, etc.

    // Roll is larger than last number in il

    return (m + (roll - il.[m-1])/50);
}
dilend



// returns an index in the list il.
// Will return a number in [0..length(il)]
// E.g. {10,75,90}
//  0 = roll <= 10
//  1 = roll in [11..75]
//  2 = roll in [76..90]
//  3 = roll > 90
//
dilbegin integer successroll(il : intlist, rollskew : integer);
external
    integer successroll_oe(il : intlist, rollskew : integer);

var
    i : integer;
code
{
    i := successroll_oe(il, rollskew);

    if (i < 0)
        return (0);

    if (i > length(il))
        return (length(il));

    return (i);
}
dilend



//
// max = length(list);
//
dilbegin integer bonuslistroll(il : intlist, bonuslvl : integer, max : integer);
external
    integer successroll_oe(il : intlist, rollskew : integer);

var
    i : integer;
code
{

    i := successroll_oe(il, 0) + bonuslvl;
    if (i < 0)
        return (0);

    if (i >= max)
        return (max-1);

    return (i);
}
dilend


// Roll for the decor on the blade which can give room for more enchantments.
// And a nice description//
dilbegin integer hiltjob(u : unitptr, lvl : integer,  hilt : string);
external
    integer successroll_oe(il : intlist, rollskew : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var 
    roll : integer;
    j : integer;
    sl : stringlist;    
    hiltmats : stringlist;    
    nHilt : integer;
    mats : stringlist;    
code
{
    // lvl is the smith roll outcome (typically 0-3 but OE)
    // u.value[1] is the smith and material bonus (up to max 7)
    // u.value[2] is the material enchantment (up to 5) plus smith bonus (usually 0-3, but Open ended)

    sl := {
        "You wonder if you can even hold onto the oddly shaped $3n $2n.",
        "The $2n is made of $3n but it isn't impressive.",
        "A functional $2n made of $3n but could look better.",
        "The $2n is made of $3n.",
        "The $2n is made of $3n and looks like it is well made.",
        "The $2n is made of $3n and looks good.",
        "The $2n is made of $3n and looks really good.",
        "The $2n is made of $3n and looks excellent.",
        "The $2n is made of $3n and a $4n is set in at the end.", 
        "The $2n is made of $3n and a $4n is set in at the end.",
        "The $2n is made of $3n and a $4n is set in at the end.",
        "The $2n is made of $3n and a $4n is set in at the end.",
        "The $2n is made of $3n and a $4n is set in at the end.",
        "The $2n is made of $3n and a $4n is set in at the end."
    };

    hiltmats := {"leather", "ivory", "iron"};
    nHilt := rnd(0, length(hiltmats)-1);

    // Roll for the decoration, typically 0-3
    roll := successroll_oe({50,75,85,95}, 0);
    log("hilt decor Roll = " + itoa(roll));

    j := u.value[2] + roll + 3;
    if (j >= length(sl))
        j := length(sl)-1;

    log("Hilt decor sum = " + itoa(j));
    log("Hilt decor: " + sl.[j]);

    if (j >= 8)
    {
        mats := { "pearl", "ruby", "diamond" };
        roll := rnd(0,2); // Pick random material
        u.value[2] := u.value[2] + roll + 1;
        log("Hilt Material : " + mats.[roll]);
        log("Hilt enchantment potential : " + itoa(u.value[2]));
        u.extra.descr := u.extra.descr + " " + sreplace(sl.[j], u.name, hilt, hiltmats.[nHilt], mats.[roll]);
    }
    else
    {
        u.extra.descr := u.extra.descr + " " + sreplace(sl.[j], u.name, hilt, hiltmats.[nHilt], "");
    }

    return (0);
}
dilend




// Roll for the decor on the blade which can give room for more enchantments.
// And a nice description//
dilbegin integer bladejob(u : unitptr, lvl : integer,  blade : string);
external
    integer successroll(il : intlist, rollskew : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var 
    roll : integer;
    j : integer;
    sl : stringlist;    
    mats : stringlist;   
code
{
    // lvl is the smith roll outcome (typically 0-3 but OE)
    // u.value[1] is the smith and material bonus (up to max 7)
    // u.value[2] is the material enchantment (up to 5) plus smith bonus (usually 0-3, but Open ended)

    sl := {
        "You wonder if that's really $1a $1n $2n, it is crooked and uneven.",
        "The $2n is crooked and could be a lot better.",
        "The $2n looks functional but could be better.",
        "The $2n is very plain.",
        "The $2n is very smooth and well made.",
        "The well made $2n is both very sharp and smooth.",
        "The well made $2n has nice engravings.",
        "The well made $2n has beautiful intricate engravings",
        "The well made $2n has beautiful intricate engravings and inlaid $3n runes.",
        "This strong $2n has $3n runes inlaid.",
        "This strong well made $2n has $3n runes inlaid.",
        "This beautiful and strong $2n has $3n runes inlaid.",
        "This is a fantastic $1n $2n which is highly decorated and with inlaid $3n runes.",
        "This is probably the most stunning $1n $2n you have ever seen, it is highly decorated and with inlaid $3n runes." 
    };

    // Roll for the decoration, typically 0-3
    roll := successroll({50,75,85,95}, 0);
    log("Blade decor Roll = " + itoa(roll));

    j := u.value[2] + roll + 3;
    if (j >= length(sl))
        j := length(sl)-1;

    log("Blade decor sum = " + itoa(j));
    log("Blade decor: " + sl.[j]);

    if (j >= 8)
    {
        mats := { "silver", "gold", "platinum" };
        roll := rnd(0,2); // Pick random material
        u.value[2] := u.value[2] + roll + 1;
        log("Material : " + mats.[roll]);
        log("Blade enchantment potential : " + itoa(u.value[2]));
        u.extra.descr := u.extra.descr + " " + sreplace(sl.[j], u.name, blade, mats.[roll], "");
    }
    else
    {
        u.extra.descr := u.extra.descr + " " + 
            sreplace(sl.[j], u.name, blade, "", "");
    }

    return (0);
}
dilend


//
// Roll for the quality of the smith work baed on the material difficulty 
// and adjust the treasure level. Append a description.
//
// Returns the smith bonus. Typically +0 to +2, but since it is open ended can be anything
//
dilbegin integer smithjob(u : unitptr, bonuslvl : integer, matlvl : integer, enchant : integer, mat : string);
external
    integer successroll_oe(il : intlist, rollskew : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var 
    roll : integer;
    q : integer;
    sl : stringlist;
    
code
{
    log("Smith Level = " + itoa(bonuslvl) + "  Material difficulty = " + itoa(matlvl));

    //
    roll := successroll_oe({40, 70, 90}, 0);
    roll := roll + (bonuslvl - matlvl);

    log("Smith roll = " + itoa(roll));

    // Adjust weapon quality
    q := u.value[1] + roll;
    if (q < -7)
        q := -7;
    if (q > 7)
        q := 7;
    u.value[1] := q;     

    log("New weapon quality is = " + itoa(q));

    // Enchantments potential
    u.value[2] := u.value[2] + roll; // +1,+2 gives more room for enchantment
    log("New weapon enchantment increased to = " + itoa(u.value[2]));

    // Get a smithing description based on weapons quality
    sl := {
        "You look at the lump of $2n and wonder if it is even $1a $1n.", // -7
        "This lump of $2n was clearly an unsuccessful attempt at making $1a $1n.",
        "This $2n $1n is terribly bad.",
        "This $2n $1n is terrible.", // -4
        "A really badly made $2n $1n.",
        "Whoever made this $2n $1n was probably the apprentice's apprentice.",
        "Not the best $2n $1n you've seen but it can come in handy.", 
        "It's $2a $2n $1n.", // 0
        "A decent $2n $1n.",  // +1
        "A good $2n $1n.",
        "This is a very good $2n $1n.",
        "An excellent $2n $1n.",
        "An excellent and well balanced $2n $1n.",
        "A superior $2n $1n.",
        "Probably the best $2n $1n you've ever seen." };

    log("weapon extra : " + sl.[u.value[1]+7]);
    u.extra.descr :=  sreplace(sl.[u.value[1]+7], u.name, mat, "", ""); 

    return (roll);
}
dilend



// Weapon id, cost, weight must be set before calling this
// Returns material level + smith level (not limited to -7 ...+7)
//
dilbegin integer metalmats(u : unitptr, lvl : integer, blade : string);
external
    integer smithjob@randomt(u : unitptr, bonuslvl : integer, matlvl : integer, enchant : integer, mat : string);
    integer bonuslistroll@randomt(il : intlist, bonuslvl : integer, max : integer);

var
    materials : stringlist;
    idxMat : integer;
    i : integer;
    s : string;
    mat : string;
    smith : integer;
    enchantments : integer;
code
{
    // material, weight-index, value-index, enchantment capacity, bonus
    // Presuming the smithing material difficulty is equal to the mat bonus
    materials := {
        "copper",     "114",      "1", "0", QUOTE(BONUS_BAD),
        "bronze",     "110",     "10", "0", QUOTE(BONUS_AVERAGE_MINUS),
        "iron",       "100",    "100", "0", QUOTE(BONUS_AVERAGE), 
        "silver",     "133",   "1000", "3", QUOTE(BONUS_AVERAGE_PLUS),
        "steel",       "90",    "500", "1", QUOTE(BONUS_GOOD),
        "high steel",  "81",    "800", "1", QUOTE(BONUS_GOOD_PLUS),
        "black steel", "71",   "5000", "2", QUOTE(BONUS_EXCELLENT),
        "true steel",  "69",  "10000", "3", QUOTE(BONUS_EXCELLENT_PLUS),
        "adamantium",  "61",  "50000", "4", QUOTE(BONUS_SUPERIOR),
        "mithril",     "50", "100000", "5", QUOTE(BONUS_ARTIFACT) };

    // First roll for a random material based on bonuslvl
    // with [il] for BONUS_AVERAGE; 56% copper, 24% bronze, 9% iron, 5%+
    //               BONUS_ARTIFACT; 56% true steel, 24% adamantium, 14% mithril

    idxMat := bonuslistroll({60,85,95}, lvl, length(materials)/5) * 5;
    mat := materials.[idxMat];
    log("Material roll = " + itoa(idxMat/5) + " " + mat);

    // Set name, title, description, extra
    addstring(u.names, mat + " " + u.name);
    u.title := "a " + mat + " " + u.name;
    u.outside_descr := "a " + mat + " " + u.name + " is laying here.";
    // XXX Add extra

    // Adjust weight for material
    set_weight_base(u, (u.weight * atoi(materials.[idxMat+1]))/100);

    // Adjust the cost for material
    u.cost := (u.cost * atoi(materials.[idxMat+2]))/10000;

    // Set the material quality bonus
    u.value[1] := atoi(materials.[idxMat+4]);
    log("Material quality bonus = " + itoa(u.value[1]));

    // Set Enchantments potential
    u.value[2] := atoi(materials.[idxMat+3]); 
    log("Material enchantment potential = " + itoa(u.value[1]));

    // Make a smithy roll for the material and adjust
    smith := smithjob@randomt(u, lvl, atoi(materials.[idxMat+3]), u.value[2], mat);

    return (smith);
}
dilend


//
// ======================== ENCHANTMENTS =========================
//


dilbegin integer enc_light(u : unitptr, bonuslvl : integer, data : string);
external
    integer successroll(il : intlist, rollskew : integer);
    identify(u :unitptr, norm : string, improved: string);
var
    i : integer;
code
{
    if (bonuslvl > 7)
    {
        bonuslvl := 7;
        log("enc_light bonuslvlifier too large ");
    }
    if (bonuslvl < -7)
    {
        bonuslvl := -7;
        log("enc_light bonuslvlifier too small ");
    }

    i := successroll({50, 80, 95}, bonuslvl*5);

    if (i == 0)
        return(1);

    setbright(u, i); // 0..3
    identify(u, "Emits a magical light.", "Emits a magical light " + itoa(i) +".");

    return (1);
}
dilend


dilbegin integer enc_dark(u : unitptr, bonuslvl : integer, data : string);
external
    integer successroll(il : intlist, rollskew : integer);
    identify(u :unitptr, norm : string, improved: string);
var
    i : integer;
code
{
    if (bonuslvl > 7)
    {
        bonuslvl := 7;
        log("enc_dark bonuslvlifier too large ");
    }
    if (bonuslvl < -7)
    {
        bonuslvl := -7;
        log("enc_dark bonuslvlifier too small ");
    }

    i := -successroll({50, 80, 95}, bonuslvl*5);

    if (i == 0)
        return(1);

    setbright(u, i); // 0..-3
    identify(u, "Emits magical darkness.", "Emits magical darkness " + itoa(i) +".");

    return (1);
}
dilend


//
// call with e.g. (u, ABIL_STR, BONUS_ARTIFACT)
//
dilbegin integer enc_ability(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);

var
    il : intlist;
    abilid : integer;
    i : integer;
    sl : stringlist;
code
{
    log("Enchant ability");
    if (bonuslvl > BONUS_ARTIFACT)
    {
        bonuslvl := BONUS_ARTIFACT;
        log("enc_ability modifier too large ");
    }
    if (bonuslvl < BONUS_JUNK)
    {
        bonuslvl:= BONUS_JUNK;
        log("enc_ability modifier too small ");
    }

    il := {-ID_RAISE_MAG, TIF_MAG_INC, TIF_MAG_DEC, 
           -ID_RAISE_DIV, TIF_DIV_INC, TIF_DIV_DEC, 
           -ID_RAISE_STR, TIF_STR_INC, TIF_STR_DEC, 
           -ID_RAISE_DEX, TIF_DEX_INC, TIF_DEX_DEC, 
           -ID_RAISE_CON, TIF_CON_INC, TIF_CON_DEC, 
           -ID_RAISE_CHA, TIF_CHA_INC, TIF_CHA_DEC, 
           -ID_RAISE_BRA, TIF_BRA_INC, TIF_BRA_DEC, 
           -ID_RAISE_HPP, TIF_HIT_INC, TIF_HIT_DEC    };


    abilid := atoi(data);
    if (abilid < ABIL_MAG)
    {
        log("Illegal ability modifier " + data);
        quit;
    }

    if (abilid >= ABIL_TREE_MAX)
    {
        log("Illegal ability modifier " + data);
        quit;
    }

    // XXX TODO. Determine how much to modify the ability

    i := getinteger(DIL_GINT_BONUS_B, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, il.[abilid*3], -1, 0,
	       abilid, i, 0,
           il.[abilid*3+1], TIF_NONE, il.[abilid*3+2], APF_ABILITY);

    sl := {"magic", "divine", "strength", "dexterity", "constitution", "charisma", "brain", "hitpoints"};
    identify(u, "Improved "+sl.[abilid] +" ability.", "Improved "+sl.[abilid]+" with "+itoa(i)+".");

    return (1);
}
dilend


// Make 4 ticks faster
dilbegin integer enc_haste(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
	addaff(u, ID_TRANSFER_SPEED, -1, 0,
	       SPEED_DEFAULT - SPEED_DEFAULT/3, 0, 0,
           TIF_SPEED_BETTER, TIF_NONE, TIF_SPEED_WORSE, APF_SPEED);

    identify(u, "Makes you hasted.", "Improved haste with +4.");

    return (1);
}
dilend


// Make 4 ticks slower
dilbegin integer enc_slow(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
	addaff(u, ID_TRANSFER_SPEED, -1, 0,
	       SPEED_DEFAULT+SPEED_DEFAULT/3, 0, 0,
           TIF_SPEED_WORSE, TIF_NONE, TIF_SPEED_BETTER, APF_SPEED);

    identify(u, "Makes you slower.", "Slows you with -4.");

    return (1);
}
dilend



dilbegin integer enc_goodprot(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
	addaff(u, ID_PROT_GOOD_TRANSFER, -1, 0,
	       0, 0, 0,
           TIF_PROT_GOOD_ON, TIF_NONE, TIF_PROT_GOOD_OFF, APF_NONE);

    identify(u, "Makes you protected against good.", "Makes you protected against good.");

    return (1);
}
dilend


dilbegin integer enc_evilprot(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
	addaff(u, ID_PROT_EVIL_TRANSFER, -1, 0,
	       0, 0, 0,
           TIF_PROT_EVIL_ON, TIF_NONE, TIF_PROT_EVIL_OFF, APF_NONE);

    identify(u, "Makes you protected against evil.", "Makes you protected against evil.");

    return (1);
}
dilend



// Resistance against spells in any spell category
//SPL_DIVINE             
//SPL_PROTECTION         
//SPL_DETECTION          
//SPL_SUMMONING          
//SPL_CREATION           
//SPL_MIND               
//SPL_HEAT               	/* Fire          */
//SPL_COLD               	/* Frost         */
//SPL_CELL               	/* Electricity   */
//SPL_INTERNAL          	/* Poison        */
//SPL_EXTERNAL          	/* Acid          */

dilbegin integer enc_resist(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var 
    splid : integer;
    sl : stringlist;
    i : integer;
code
{
    splid := atoi(data);

    if (splid < SPL_DIVINE)
    {
        log("OOB LB spell id " + data);
        quit;
    }

    if (splid >= SPL_GROUP_MAX)
    {
        log("OOB UB spell id " + data);
        quit;
    }

    i := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, -ID_SPELL_DEFENSE, -1, 0,
	       splid, i, 0,
           TIF_SPL_INC, TIF_NONE, TIF_SPL_DEC, APF_SPELL_ADJ);

    sl := {"", "divination", "protection", "detection", "summoning", "creation", 
           "mind", "fire", "cold", "electricity", "poison", "acid"};

    identify(u, "Increases your resistance against " + sl.[splid] + ".",
                "Increases your resistance against " + sl.[splid] + " by " + itoa(i) + ".");

    return (1);
}
dilend


// Weapon defense
// WPN_AXE_HAM   1		/* Axe/hammer category        */
// WPN_SWORD     2		/* Sword Category             */
// WPN_CLUB_MACE 3		/* Club/Mace/Flail Category   */
// WPN_POLEARM   4		/* Polearm category           */
// WPN_UNARMED   5		/* Natural attacks            */
// WPN_SPECIAL   6		/* Special weapons            */
// WPN_GROUP_MAX 7		/* #[0..6] of groups          */

dilbegin integer enc_defense(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var 
    defid : integer;
    i : integer;
    sl : stringlist;
code
{
    defid := atoi(data);

    if (defid < WPN_AXE_HAM)
    {
        log("OOB LB wpn id " + data);
        quit;
    }

    if (defid >= WPN_GROUP_MAX)
    {
        log("OOB UB wpn id " + data);
        quit;
    }

    i := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, -ID_WEAPON_DEFENSE, -1, 0,
	       defid, i, 0,
           TIF_WPN_INC, TIF_NONE, TIF_WPN_DEC, APF_WEAPON_ADJ);

    sl := {"", "axes and hammers", "bladed weapons", "clubs and maces", "polearms", "natural attacks", "special weapons"};

    identify(u, "Increases your defense against " + sl.[defid] + ".",
                "Increases your defense against " + sl.[defid] + " by " + itoa(i) + ".");

    return (1);
}
dilend


dilbegin integer enc_slaying(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);

var
    il : intlist;
    sl : stringlist;
    i : integer;
code
{
    il := {
        RACE_DRAGON_BLACK, 
        RACE_DRAGON_BLUE, 
        RACE_DRAGON_GREEN,
        RACE_DRAGON_RED,
        RACE_DRAGON_WHITE,
        RACE_DRAGON_SILVER
    };

    sl := {
        "black dragons",
        "blue dragons", 
        "green dragons",
        "red dragons",
        "white dragons",
        "silver dragons"
    };

    i := rnd(0,length(il)-1);

    u.value[3] := il.[i];
    identify(u, "", "Slaying against "+sl.[i]+".");

    return (1);
}
dilend



dilbegin integer enc_magicbonus(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
code
{
    u.value[2] := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (u.value[2] == 0)
        return(1);

    identify(u, "Confers a magic attack bonus.", "Confers a magic attack bonus of " + itoa(u.value[2])+".");
    return (1);
}
dilend

dilbegin integer enc_wpnattack(u : unitptr, bonuslvl : integer, data : string);
external
    identify(u :unitptr, norm : string, improved: string);
var
    i : integer;
code
{
    i := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);

    if (i == 0)
        return(1);

	addaff(u, -ID_WEAPON_DEFENSE, -1, 0,
	       u.value[0], i, 0,
           TIF_WPN_INC, TIF_NONE, TIF_WPN_DEC, APF_WEAPON_ADJ);

    identify(u, "Increases your skill with this weapon.",
                "Increases your skill with this weapon by " + itoa(i)+".");

    return (1);
}
dilend


dilbegin integer encWpn(u : unitptr, bonuslvl : integer, blade : string);
external 
    integer successroll(il : intlist, rollskew : integer);

var
    enchantments : integer;
    used : stringlist;
    encn : intlist;
    encs : stringlist;
    i : integer;
    s : string;
code
{
    u.flags := u.flags | UNIT_FL_MAGIC;
    enchantments := u.value[2];
    log("here we're supposed to enchant the weapon: " + itoa(enchantments));

    encn := {
         4, // enc_light
         6, 8, 10, 12, 14, 16, 18, 20, // enc_ability
         26, // enc_haste,
         27, // enc_slow,
         30, // enc_goodprot,
         33, // enc_evilprot,
         35, 36, 37, 38, 39, 41, 44, 47, 50, 53, 56, // enc_resist
         58,60,62,64,66,68, // enc_defense
         70,                // enc_slaying
         80                 // wpnattack+
                            // magicbonus+ for anythnig above the previous 
    };

    encs := {
        "enc_light@randomt", "0",
        "enc_ability@randomt", QUOTE(ABIL_MAG),
        "enc_ability@randomt", QUOTE(ABIL_DIV),
        "enc_ability@randomt", QUOTE(ABIL_STR),
        "enc_ability@randomt", QUOTE(ABIL_DEX),
        "enc_ability@randomt", QUOTE(ABIL_CON),
        "enc_ability@randomt", QUOTE(ABIL_CHA),
        "enc_ability@randomt", QUOTE(ABIL_BRA),
        "enc_ability@randomt", QUOTE(ABIL_HP),
        "enc_haste@randomt", "0",
        "enc_slow@randomt", "0",
        "enc_goodprot@randomt", "0",
        "enc_evilprot@randomt", "0",
        "enc_resist@randomt", QUOTE(SPL_DIVINE),
        "enc_resist@randomt", QUOTE(SPL_PROTECTION),
        "enc_resist@randomt", QUOTE(SPL_SUMMONING),
        "enc_resist@randomt", QUOTE(SPL_CREATION),
        "enc_resist@randomt", QUOTE(SPL_DETECTION),
        "enc_resist@randomt", QUOTE(SPL_MIND),
        "enc_resist@randomt", QUOTE(SPL_HEAT),
        "enc_resist@randomt", QUOTE(SPL_COLD),
        "enc_resist@randomt", QUOTE(SPL_CELL),     // Electricity
        "enc_resist@randomt", QUOTE(SPL_INTERNAL), // Poison
        "enc_resist@randomt", QUOTE(SPL_EXTERNAL),  // Acid
        "enc_defense@randomt", QUOTE(WPN_AXE_HAM),
        "enc_defense@randomt", QUOTE(WPN_SWORD),
        "enc_defense@randomt", QUOTE(WPN_CLUB_MACE),
        "enc_defense@randomt", QUOTE(WPN_POLEARM),
        "enc_defense@randomt", QUOTE(WPN_UNARMED),
        "enc_defense@randomt", QUOTE(WPN_SPECIAL),
        "enc_slaying@randomt", "0",
        "enc_wpnattack@randomt", "0",
        "enc_magicbonus@randomt", "0" };

        //   Add SLAYING
        //
        //   Possible expansions
        //     Maybe go through affect list and pick more such as bless, etc.
        //     Weapon has embedded spells that can be used X times / day
        //     Fireblade, Coldblade, Electricity, (how?)
        //     Soul saver?
        //     Fights for you while you're down

    if (length(encn)+1 != length(encs)/2)
    {
        log("ERROR: The two arrays must be in sync");
        quit;
    }

    while (enchantments > 0)
    {
        log("enchantment "+itoa(enchantments));
        enchantments := enchantments - 1;

        i := successroll(encn, 0);
        s := itoa(i);
        if (length(s) < 2)
            s := "0" + s;
        if (s in used)
            continue;
        insert(used, 0, s);

        if (i < 0)
        {
            log("Index too low");
            quit;
        }

        if (i >= length(encs)/2)
        {
            log("Index too high");
            quit;
        }

        i := dilcall(encs.[i*2])(u, bonuslvl, encs.[i*2+1]);
    }

    return (0);
}
dilend

// For generating metal weapons with hilts / shafts such as swords, axes, 
// maces, tridents, spears, javelins, etc.
//
// bonuslvl    : BONUS_XXX (0-7) of the quality of weapon to create
// wpnid       : WPN_XXX type of weapon to create, e.g. WPN_JAVELIN
// dflcost     : Default cost of the weapon if it was made in iron
// dflweight   : Default weight of the weapon
// dflsize     : Default size of the weapon (170cm?)
// materialdil : the DIL to generate the material
// bladedil    : the DIL to process the blade / point / head of the weapon
// hiltdil     : the DIL to process the hilt / shaft of the weapon
//
dilbegin unitptr metalweapon(bonuslvl : integer, wpnid : integer, 
                                 dflcost : integer, dflweight : integer, dflsize : integer,
                                 blade : string,
                                 hilt : string,
                                 materialdil : string,
                                 bladedil : string,
                                 hiltdil : string);

external
    treasureroll(u : unitptr, bonuslvl : integer);
    integer encWpn(u : unitptr, lvl : integer, blade : string);
    integer bladejob@randomt(u : unitptr, lvl : integer,  blade : string);
    integer hiltjob@randomt(u : unitptr, lvl : integer,  blade : string);
    identify(u :unitptr, norm : string, improved: string);

var
    u : unitptr;
    wpns : stringlist;
    i : integer;
    smith : integer;
    s : string;
    t : string;
    enchantments : integer;
code
{
    u := load("weapon_rnd@randomt");
    if (u == null)
    {
        log("Unable to load basis weapon");
        quit;
    }

    u.value[0] := wpnid;
    s := weapon_name(wpnid);
    u.names.[0] := s;

    // add a placeholder for appending descriptions 
    addextra(u.extra, {""}, "");

    set_weight_base(u, dflweight);
    u.height := dflsize;
    u.cost := dflcost;

    treasureroll(u, bonuslvl);

    // Find primary weapon material and smith job, gets 
    smith := dilcall(materialdil)(u, bonuslvl, blade); 
    i := dilcall(bladedil)(u, smith, blade);
    i := dilcall(hiltdil)(u, smith,  hilt);

    u.value[1] := getinteger(DIL_GINT_BONUS_A, null, bonuslvl);
    if (u.value[1] > 0)
        identify(u, "Weapon has a quality bonus.", "Weapon has a quality bonus of " + itoa(u.value[1]) + ".");
    else if (u.value[1] < 0)
        identify(u, "Weapon has a quality penalty.", "Weapon has a quality penalty of " + itoa(u.value[1]) + ".");

    // u.value[2] contains the # of enchantments for this weapon
    if (u.value[2] > 0)  // Move to enchant
        i := encWpn@randomt(u, bonuslvl, blade);

    u.extra.vals := {};

    return(u);
}
dilend



//
// XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
//


// ========================= MATERIALS ==========================

// Main metals for metal weapons, e.g. a long sword or mace made of iron
// (handle / hilt is another matter). Matroll [-7..+7]
//
dilbegin string matMetal(matlvl : integer);
var 
    materials : stringlist;
code
{
    materials := {
        "coroded copper", "coroded copper", "worn copper", "worn copper", "worn copper", "copper", "bronze",
        "iron",
        "silver", "steel", "high steel", "black steel", "true steel", "adamantium", "mithril"};

    return (materials.[matlvl+7]);
}
dilend


// Metals for enchantment, e.g. inlaid runes, enclvl[-7..+7]
//
dilbegin string matMetalEnc(enclvl : integer);
var 
    materials : stringlist;
code
{
    materials := {
        "", "", "", "", "", "", "",
        "",
        "silver", "silver", "silver", "silver", "red gold", "gold", "platinum"};

    return (materials.[enclvl+7]);
}
dilend


// Metals for the hilt, hiltlvl[-7..+7]
//
dilbegin string matHilt(hiltlvl : integer);
var 
    i : integer;
    materials : stringlist;
code
{
    materials := {
        "wood", "wood", "wood", "wood", "bone", "bone", "bone",
        "iron",
        "silver", "steel", "high steel", "black steel", "true steel", "adamantium", "mithril"};

    return (materials.[hiltlvl+7]);
}
dilend


// Gem for e.g. a hilt [-7..+7]
//
dilbegin string matGem(gemlvl : integer);
var 
    materials : stringlist;
code
{
    materials := {
        "", "", "", "", "", "", "",
        "",
        "pearl", "black pearl", "moonstone", "emerald", "sapphire", "ruby", "diamond"};

    return (materials.[gemlvl+7]);
}
dilend


// ========================= LYRICS ==========================

// For e.g. a long sword, made of mithril, set the title and name
// and outside description to ...mihtril long sword...
//
dilbegin setMatDescr(u : unitptr, mat : string);
var
    ana : string;
code
{
    if (mat.[0] in "aeiou")
        ana := "an ";
    else
        ana := "a ";

    // Set name, title, description, extra
    addstring(u.names, mat + " " + u.name);
    u.title := ana + mat + " " + u.name;
    u.outside_descr := ana + mat + " " + u.name + " is laying here.";

    return;
}
dilend



// For the weapon u, set an appropriate overall smithing description 
// based on the success of the smithing roll [-7..+7]
//
dilbegin setJewelrySmith(u : unitptr, mat : string, smithlvl : integer);
external
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var
    sl : stringlist;
    exd : extraptr;
code
{
    // Get a smithing description based on weapons quality
    sl := {
        "You look at the lump of $2n and wonder if it is even $1a $1n.", // -7
        "This lump of $2n was clearly an unsuccessful attempt at making $1a $1n.",
        "This $2n $1n is terribly bad.",
        "This $2n $1n is terrible.", // -4
        "A really badly made $2n $1n.",
        "Whoever made this $2n $1n was probably the apprentice's apprentice.",
        "Not the best $2n $1n you've seen but it can come in handy.", 
        "It's $2a $2n $1n.", // 0
        "A pretty $2n $1n.",  // +1
        "A pretty well made$2n $1n.",
        "A beautiful $2n $1n.",
        "A beautiful well made $2n $1n.",
        "A stunning $2n $1n.",
        "A stunning well made $2n $1n.",
        "Probably the most beautiful $2n $1n you've ever seen." };

    log("Jewelry extra : " + sl.[smithlvl+7]);

    exd := "" in u.extra;
    exd.descr :=  sreplace(sl.[smithlvl+7], u.name, mat, "", "");

    log("exd name = [" + exd.name + "] descr = " + exd.descr);

    return;
}
dilend


dilbegin setJewelryGem(u : unitptr, mat2 : integer, mat3 : integer, kind : string);
external
    string matGem(gemlvl : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var
    sl : stringlist;
    gem : string;
    t : string;
    r : string;
    exd : extraptr;
code
{
    gem := matGem(mat2);
    if (gem == "")
        return;

    sl := {
        "", // -7
        "",
        "",
        "",
        "",
        "",
        "A tiny broken $2n is set in the $1n.",
        "A tiny $2n is set in the $1n.", // 0
        "A tiny flawless $2n is set in the $1n.",
        "A small $2n is set in the $1n.",
        "A small flawless $2n is set in the $1n.",
        "A medium sized $2n is set in the $1n.",
        "A medium sized flawless $2n is set in the $1n.",
        "A large $2n is set in the $1n.",
        "A large flawless $2n is set in the $1n." // +7
    };

    r := sreplace(sl.[mat3+7], u.name, gem, "", "");

    log("Gem extra: " + r);

    exd := "" in u.extra;
    exd.descr := exd.descr + " " + r;
    log("Gem name = [" + exd.name + "]  descr="+exd.descr);

    return;
}
dilend



// For the weapon u, set an appropriate overall smithing description 
// based on the success of the smithing roll [-7..+7]
//
dilbegin setWpnSmithing(u : unitptr, mat : string, smithlvl : integer);
external
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);
var
    sl : stringlist;
    exd : extraptr;
code
{
    // Get a smithing description based on weapons quality
    sl := {
        "You look at the lump of $2n and wonder if it is even $1a $1n.", // -7
        "This lump of $2n was clearly an unsuccessful attempt at making $1a $1n.",
        "This $2n $1n is terribly bad.",
        "This $2n $1n is terrible.", // -4
        "A really badly made $2n $1n.",
        "Whoever made this $2n $1n was probably the apprentice's apprentice.",
        "Not the best $2n $1n you've seen but it can come in handy.", 
        "It's $2a $2n $1n.", // 0
        "A decent $2n $1n.",  // +1
        "A good $2n $1n.",
        "This is a very good $2n $1n.",
        "An excellent $2n $1n.",
        "An excellent and well balanced $2n $1n.",
        "A superior $2n $1n.",
        "Probably the best $2n $1n you've ever seen." };

    log("weapon extra : " + sl.[smithlvl+7]);

    exd := "" in u.extra;
    exd.descr :=  sreplace(sl.[smithlvl+7], u.name, mat, "", "");

    log("exd name = [" + exd.name + "] descr = " + exd.descr);

    return;
}
dilend


// lvl1 - skill of making the blade
// lvl2 - material for inlaid runes / engravings
//
dilbegin setWpnBlade(u : unitptr, lvl1 : integer, lvl2 : integer, kind : string);
external
    string matMetalEnc(enclvl : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var
    sl : stringlist;
    s : string;
    t : string;
    exd : extraptr;
code
{
    sl := {
        "You wonder if that's really $1a $1n $2n, it is crooked and uneven.",
        "The $2n is crooked and could be a lot better.",
        "The $2n looks functional but could be better.",
        "The $2n is very plain.",
        "The $2n is very smooth and well made.",
        "The well made $2n is both very sharp and smooth.",
        "The well made $2n has nice engravings.",
        "The well made $2n has beautiful intricate engravings",
        "The well made $2n has beautiful intricate engravings and inlaid $3n runes.",
        "It's strong $2n has $3n runes inlaid.",
        "It's strong well made $2n has $3n runes inlaid.",
        "It's beautiful and strong $2n has $3n runes inlaid.",
        "It's fantastic $1n $2n which is highly decorated and with inlaid $3n runes.",
        "It's probably the most stunning $1n $2n you have ever seen, it is highly decorated and with inlaid $3n runes." 
    };

    s := sl.[lvl1 + 7];
    log("Blade : " + s);

    t := matMetalEnc(lvl2);
    exd := "" in u.extra;
    exd.descr := exd.descr + " " + sreplace(s, u.name, kind, t, "");
    log("setWpnBlade extra : " + exd.descr);

    return;
}
dilend


dilbegin setWpnHilt(u : unitptr, mat2 : integer, mat3 : integer, kind : string);
external
    string matHilt(hiltlvl : integer);
    string matGem(gemlvl : integer);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var
    sl : stringlist;
    s : string;
    t : string;
    r : string;
    exd : extraptr;
code
{
    // Fix the hilt
    sl := {
        "You wonder if you can even hold onto the oddly shaped $3n $2n.", // -7
        "The $2n is made of $3n but it isn't impressive.",
        "A functional $2n made of $3n but could look better.",
        "The $2n is made of $3n.",
        "The $2n is made of $3n and looks like it is well made.",
        "The $2n is made of $3n and looks good.",
        "The $2n is made of $3n and looks really good.",
        "The $2n is made of $3n and looks excellent.",  // 0
        "The $2n is made of $3n and $4n is set in at the end.", 
        "The $2n is made of $3n and $4n is set in at the end.",
        "The $2n is made of $3n and $4n is set in at the end.",
        "The $2n is made of $3n and $4n is set in at the end.",
        "The $2n is made of $3n and $4n is set in at the end.",
        "The $2n is made of $3n and $4n is set in at the end.",
        "The $2n is made of $3n and $4n is set in at the end." // +7
    };

    s := matHilt(mat2);
    t := matGem(mat3);
    r := sreplace(sl.[mat2+7], u.name, kind, s, t);

    log("Hilt decor: " + r);

    exd := "" in u.extra;
    exd.descr := exd.descr + " " + r;
    log("setWpnHilt name = [" + exd.name + "]  descr="+exd.descr);

    return;
}
dilend


// ========================= ?CATEGORY? ==========================


dilbegin integer matJewelry(u : unitptr, bonuslvl : integer, data : string);
external
    string matMetal(roll : integer);
    setMatDescr(u : unitptr, mat : string);
    setJewelrySmith(u : unitptr, mat : string, smithlvl : integer);
    setJewelryGem(u : unitptr, mat2 : integer, mat3 : integer, kind : string);

var
    rollsmith : integer;
    mat1 : integer;
    mat2 : integer;
    mat3 : integer;
    rollenc : integer;
    enc1 : integer;
    s : string;
    t : string;
    i : integer;
    sl : stringlist;

code
{
    log("matJewelry");

    rollsmith := u.extra.vals.[0];  // Smithing roll
    mat1 := u.extra.vals.[1];  // Primary jewelry material
    mat2 := u.extra.vals.[2];  // Secondary jewelry material
    mat3 := u.extra.vals.[3];  // Tertiary jewelry material
    rollenc := u.extra.vals.[4];  // 
    enc1 := u.extra.vals.[5];  // 

    // Get the main jewelry material
    s := matMetal(mat1);

    setMatDescr(u, s);

    setJewelrySmith(u, s, i);
    setJewelryGem(u, mat2, mat3, "");

    return (0);
}
dilend


dilbegin integer matWpnBlade(u : unitptr, bonuslvl : integer, data : string);
external
    setMatDescr(u : unitptr, mat : string);
    setWpnSmithing(u : unitptr, mat : string, smithlvl : integer);
    identify(u :unitptr, norm : string, improved: string);
    string matMetal(roll : integer);
    setWpnHilt(u : unitptr, mat2 : integer, mat3 : integer, kind : string);
    setWpnBlade(u : unitptr, lvl1 : integer, lvl2 : integer, kind : string);
    string sreplace(s : string, a1: string, a2 : string, a3 : string, a4 : string);

var
    rollsmith : integer;
    mat1 : integer;
    mat2 : integer;
    mat3 : integer;
    rollenc : integer;
    enc1 : integer;
    s : string;
    t : string;
    i : integer;
    sl : stringlist;

code
{
    log("matWpnBlade");

    rollsmith := u.extra.vals.[0];  // Smithing roll
    mat1 := u.extra.vals.[1];  // Primary blade material
    mat2 := u.extra.vals.[2];  // Primary hilt material
    mat3 := u.extra.vals.[3];  // [Primary hilt gemstone]
    rollenc := u.extra.vals.[4];  // 
    enc1 := u.extra.vals.[5];  // 

    // Get the main bladed weapon material
    s := matMetal(mat1);

    setMatDescr(u, s);
    
    i := (rollsmith + mat1) / 2; // Set average weapon material bonus [-7..+7]
    u.value[1] := getinteger(DIL_GINT_BONUS_A, null, i);
    if (u.value[1] > 0)
        identify(u, "Weapon has a quality bonus.", "Weapon has a quality bonus of +" + itoa(u.value[1]) + ".");
    else if (u.value[1] < 0)
        identify(u, "Weapon has a quality penalty.", "Weapon has a quality penalty of " + itoa(u.value[1]) + ".");

    setWpnSmithing(u, s, i);

    sl := split(data, "//");

    setWpnBlade(u, rollEnc, enc1, sl.[0]);
    setWpnHilt(u, mat2, mat3, sl.[1]);

    return (0);
}
dilend



// ========================= ENCHANT ITEM ==========================
dilbegin integer encJewelry(u : unitptr, bonuslvl : integer, data : string);
external 
    integer successroll(il : intlist, rollskew : integer);

var
    enchantments : integer;
    lvl : integer;
    i : integer;
    s : string;
    encn : intlist;
    encs : stringlist;
    used : stringlist;

    rollenc : integer;
    enc1 : integer;
    enc2 : integer;
    enc3 : integer;

    exd : extraptr;
code
{
    exd := "" in u.extra;
    rollenc := exd.vals.[4]; // Enchantment roll
    enc1 := exd.vals.[5];    // enchantment material 1
    enc2 := exd.vals.[6];    // enchantment material 2
    enc3 := exd.vals.[7];    // enchantment material 3

    lvl := (rollenc + enc1 + enc2 + enc3) / 4; // Take the average

    log("encWpnNew() lvl = " + itoa(lvl));

    if (lvl == 0)
        return (0);

    u.flags := u.flags | UNIT_FL_MAGIC;

    log("Enchant the jewelry: lvl=" + itoa(lvl) + " u.value2="+itoa(u.value[2]));

    encn := {
         4, // enc_light
         6, 8, 10, 12, 14, 16, 18, 20, // enc_ability
         26, // enc_haste,
         27, // enc_slow,
         30, // enc_goodprot,
         33, // enc_evilprot,
         35, 36, 37, 38, 39, 41, 44, 47, 50, 53, 56, // enc_resist
         58,60,62,64,66,68  // enc_defense
    }; // XXX    NEED TO FIX THIS SO WE DONT ROLL TOO MANY TIMES

    encs := {
        "enc_light@randomt", "0",
        "enc_ability@randomt", QUOTE(ABIL_MAG),
        "enc_ability@randomt", QUOTE(ABIL_DIV),
        "enc_ability@randomt", QUOTE(ABIL_STR),
        "enc_ability@randomt", QUOTE(ABIL_DEX),
        "enc_ability@randomt", QUOTE(ABIL_CON),
        "enc_ability@randomt", QUOTE(ABIL_CHA),
        "enc_ability@randomt", QUOTE(ABIL_BRA),
        "enc_ability@randomt", QUOTE(ABIL_HP),
        "enc_haste@randomt", "0",
        "enc_slow@randomt", "0",
        "enc_goodprot@randomt", "0",
        "enc_evilprot@randomt", "0",
        "enc_resist@randomt", QUOTE(SPL_DIVINE),
        "enc_resist@randomt", QUOTE(SPL_PROTECTION),
        "enc_resist@randomt", QUOTE(SPL_SUMMONING),
        "enc_resist@randomt", QUOTE(SPL_CREATION),
        "enc_resist@randomt", QUOTE(SPL_DETECTION),
        "enc_resist@randomt", QUOTE(SPL_MIND),
        "enc_resist@randomt", QUOTE(SPL_HEAT),
        "enc_resist@randomt", QUOTE(SPL_COLD),
        "enc_resist@randomt", QUOTE(SPL_CELL),     // Electricity
        "enc_resist@randomt", QUOTE(SPL_INTERNAL), // Poison
        "enc_resist@randomt", QUOTE(SPL_EXTERNAL),  // Acid
        "enc_defense@randomt", QUOTE(WPN_AXE_HAM),
        "enc_defense@randomt", QUOTE(WPN_SWORD),
        "enc_defense@randomt", QUOTE(WPN_CLUB_MACE),
        "enc_defense@randomt", QUOTE(WPN_POLEARM),
        "enc_defense@randomt", QUOTE(WPN_UNARMED),
        "enc_defense@randomt", QUOTE(WPN_SPECIAL)
        };

        //   Possible expansions
        //     Maybe go through affect list and pick more such as bless, etc.
        //     Weapon has embedded spells that can be used X times / day
        //     Fireblade, Coldblade, Electricity, (how?)
        //     Soul saver?
        //     Fights for you while you're down

    if (length(encn) != length(encs)/2)
    {
        log("ERROR: The two arrays must be in sync");
        quit;
    }

    enchantments := lvl;
    while (enchantments > 0)
    {
        log("enchantment "+itoa(enchantments));
        enchantments := enchantments - 1;

        i := successroll(encn, 0);
        s := itoa(i);
        if (length(s) < 2)
            s := "0" + s;
        if (s in used)
            continue;
        insert(used, 0, s);

        if (i < 0)
        {
            log("Index too low");
            quit;
        }

        if (i >= length(encs)/2)
        {
            continue;
            log("Index too high");
            quit;
        }

        i := dilcall(encs.[i*2])(u, lvl, encs.[i*2+1]);
    }

    return (0);
}
dilend



dilbegin integer encWpnNew(u : unitptr, bonuslvl : integer, blade : string);
external 
    integer successroll(il : intlist, rollskew : integer);

var
    enchantments : integer;
    lvl : integer;
    i : integer;
    s : string;
    encn : intlist;
    encs : stringlist;
    used : stringlist;

    rollenc : integer;
    enc1 : integer;
    enc2 : integer;
    enc3 : integer;

    exd : extraptr;
code
{
    exd := "" in u.extra;
    rollenc := exd.vals.[4]; // Enchantment roll
    enc1 := exd.vals.[5];    // enchantment material 1
    enc2 := exd.vals.[6];    // enchantment material 2
    enc3 := exd.vals.[7];    // enchantment material 3

    lvl := (rollenc + enc1 + enc2 + enc3) / 4; // Take the average

    log("encWpnNew() lvl = " + itoa(lvl));

    if (lvl == 0)
        return (0);

    u.flags := u.flags | UNIT_FL_MAGIC;

    log("Enchant the weapon: lvl=" + itoa(lvl) + " u.value2="+itoa(u.value[2]));

    encn := {
         4, // enc_light
         6, 8, 10, 12, 14, 16, 18, 20, // enc_ability
         26, // enc_haste,
         27, // enc_slow,
         30, // enc_goodprot,
         33, // enc_evilprot,
         35, 36, 37, 38, 39, 41, 44, 47, 50, 53, 56, // enc_resist
         58,60,62,64,66,68, // enc_defense
         70,                // enc_slaying
         80                 // wpnattack+
                            // magicbonus+ for anythnig above the previous 
    };

    encs := {
        "enc_light@randomt", "0",
        "enc_ability@randomt", QUOTE(ABIL_MAG),
        "enc_ability@randomt", QUOTE(ABIL_DIV),
        "enc_ability@randomt", QUOTE(ABIL_STR),
        "enc_ability@randomt", QUOTE(ABIL_DEX),
        "enc_ability@randomt", QUOTE(ABIL_CON),
        "enc_ability@randomt", QUOTE(ABIL_CHA),
        "enc_ability@randomt", QUOTE(ABIL_BRA),
        "enc_ability@randomt", QUOTE(ABIL_HP),
        "enc_haste@randomt", "0",
        "enc_slow@randomt", "0",
        "enc_goodprot@randomt", "0",
        "enc_evilprot@randomt", "0",
        "enc_resist@randomt", QUOTE(SPL_DIVINE),
        "enc_resist@randomt", QUOTE(SPL_PROTECTION),
        "enc_resist@randomt", QUOTE(SPL_SUMMONING),
        "enc_resist@randomt", QUOTE(SPL_CREATION),
        "enc_resist@randomt", QUOTE(SPL_DETECTION),
        "enc_resist@randomt", QUOTE(SPL_MIND),
        "enc_resist@randomt", QUOTE(SPL_HEAT),
        "enc_resist@randomt", QUOTE(SPL_COLD),
        "enc_resist@randomt", QUOTE(SPL_CELL),     // Electricity
        "enc_resist@randomt", QUOTE(SPL_INTERNAL), // Poison
        "enc_resist@randomt", QUOTE(SPL_EXTERNAL),  // Acid
        "enc_defense@randomt", QUOTE(WPN_AXE_HAM),
        "enc_defense@randomt", QUOTE(WPN_SWORD),
        "enc_defense@randomt", QUOTE(WPN_CLUB_MACE),
        "enc_defense@randomt", QUOTE(WPN_POLEARM),
        "enc_defense@randomt", QUOTE(WPN_UNARMED),
        "enc_defense@randomt", QUOTE(WPN_SPECIAL),
        "enc_slaying@randomt", "0",
        "enc_wpnattack@randomt", "0",
        "enc_magicbonus@randomt", "0" };

        //   Possible expansions
        //     Maybe go through affect list and pick more such as bless, etc.
        //     Weapon has embedded spells that can be used X times / day
        //     Fireblade, Coldblade, Electricity, (how?)
        //     Soul saver?
        //     Fights for you while you're down

    if (length(encn)+1 != length(encs)/2)
    {
        log("ERROR: The two arrays must be in sync");
        quit;
    }

    enchantments := lvl;
    while (enchantments > 0)
    {
        log("enchantment "+itoa(enchantments));
        enchantments := enchantments - 1;

        i := successroll(encn, 0);
        s := itoa(i);
        if (length(s) < 2)
            s := "0" + s;
        if (s in used)
            continue;
        insert(used, 0, s);

        if (i < 0)
        {
            log("Index too low");
            quit;
        }

        if (i >= length(encs)/2)
        {
            log("Index too high");
            quit;
        }

        i := dilcall(encs.[i*2])(u, lvl, encs.[i*2+1]);
    }

    return (0);
}
dilend


// ========================= GENERAL TREASURE ==========================

// Find treasure's materials, adjust cost, adjust weight
// When finished u.extra.vals holds the rolls [-10..10] like this
//   {Craftsmanship, mat1, mat2, mat3, Enchantment, enc1, enc2, enc3}
//
dilbegin treasureroll(u : unitptr, bonuslvl : integer);
external
    integer successroll_oe(il : intlist, rollskew : integer);
    integer minmax7(i : integer);

var
    rollmat : integer;
    mat1 : integer;
    mat2 : integer;
    mat3 : integer;
    
    rollenc : integer;
    enc1 : integer;
    enc2 : integer;
    enc3 : integer;

    il : intlist;
code
{
    log("treasureroll");
    if (u.extra == null)
        addextra(u.extra, {""}, "");

    rollmat := (7*(successroll_oe({45,70,90}, 0) + bonuslvl))/10;
    rollmat := minmax7(rollmat);
    mat1 := minmax7(rollmat + rnd(-1,1));
    mat2 := minmax7(rollmat + rnd(-1,1));
    mat3 := minmax7(rollmat + rnd(-1,1));

    rollenc := (7*(successroll_oe({45,70,90}, 0) + bonuslvl))/10;
    rollenc := minmax7(rollenc);
    enc1 := minmax7(rollenc + rnd(-1,1));
    enc2 := minmax7(rollenc + rnd(-1,1));
    enc3 := minmax7(rollenc + rnd(-1,1));

    // TODO:
    // Adjust cost, weight based on these
    //

    il := {};
    insert(il, 0, rollmat);
    insert(il, 1, mat1);
    insert(il, 2, mat2);
    insert(il, 3, mat3);
    insert(il, 4, rollenc);
    insert(il, 5, enc1);
    insert(il, 6, enc2);
    insert(il, 7, enc3);

    u.extra.vals := il;

    return;
}
dilend



dilbegin unitptr treasureize(u : unitptr, bonuslvl : integer,
                             matDil : string, matArg : string, 
                             encDil : string, encArg : string);
external
    treasureroll(u : unitptr, bonuslvl : integer);
var
    i : integer;
code
{
    treasureroll(u, bonuslvl);

    if (matDil != "")
        i := dilcall(matDil)(u, bonuslvl, matArg); 

    if (encDil != "")
        i := dilcall(encDil)(u, bonuslvl, encArg);

    // u.extra.vals := {};  // remove temporary storage of rolls

    return(u);
}
dilend


dilbegin unitptr createItem(itemname : string,
                            item_type : integer, price : integer, size : integer, lbs : integer);
var
    u : unitptr;
code
{
    u := load("weapon_rnd@randomt");

    u.objecttype := item_type;
    u.names.[0] := itemname;

    u.cost := price;
    set_weight_base(u, lbs);
    u.height := size;

    return (u);
}
dilend


// ========================= CREATE ITEM TYPE ==========================

dilbegin unitptr createBladeHilt(bonuslvl : integer);
external
    unitptr treasureize(u : unitptr, bonuslvl : integer,
                             matDil : string, matArg : string, 
                             encDil : string, encArg : string);
    unitptr createItem(itemname : string,
                            item_type : integer, price : integer, size : integer, lbs : integer);
var
    u : unitptr;
    wpns : intlist;
    idxWpn : integer;
    s : string;
code
{
    // weapon id, cost cp, weight
    wpns := {
                WPN_GREAT_SWORD,   200, 16,
                WPN_LONG_SWORD,    100, 8,
                WPN_BROAD_SWORD,   100, 8,
                WPN_CLAYMORE,      120, 9,
                WPN_SCIMITAR,      100, 7,
                WPN_FALCHION,       90, 9,
                WPN_SHORT_SWORD,    70, 6,
                WPN_RAPIER,         60, 4,
                WPN_MAIN_GAUCHE,    50, 2,
                WPN_STILETTO,       40, 1,
                WPN_DAGGER,         40, 1
            };

    log("Random bladed weapon, with a *blade* and a *hilt*");
    idxWpn := rnd(0,length(wpns)/3-1) * 3;

    u := createItem(weapon_name(wpns.[idxWpn]), ITEM_WEAPON, wpns.[idxWpn+1], 180, wpns.[idxWpn+2]);
    u.manipulate := u.manipulate | MANIPULATE_WIELD;
    u.value[0] := wpns.[idxWpn]; // Set the weapon type

    treasureize(u, bonuslvl, "matWpnBlade@randomt", "blade//hilt", "encWpnNew@randomt", "blade//hilt");

    return(u);
}
dilend



dilbegin unitptr createHeadHand(bonuslvl : integer);
external
    unitptr treasureize(u : unitptr, bonuslvl : integer,
                        matDil : string, matArg : string, 
                        encDil : string, encArg : string);
    unitptr createItem(itemname : string,
                        item_type : integer, price : integer, size : integer, lbs : integer);
var
    u : unitptr;
    wpns : intlist;
    idxWpn : integer;
    s : string;
code
{
    log("Random head / shaft");

    // weapon id, cost cp, weight
    wpns := {
            WPN_BATTLE_AXE,    160, 16,
            WPN_HAND_AXE,       60, 6,
            WPN_WAR_MATTOCK,    90, 10,
            WPN_ADZE,           70, 7,
            WPN_WAR_MAUL,       60, 9,
            WPN_WAR_HAMMER,     55, 7,
            WPN_BATTLE_CLUB,    50, 6,  // Will these be OK?
            WPN_CLUB,           20, 4,
            WPN_BATTLE_MACE,    80, 12,
            WPN_MACE,           60, 6,
            WPN_FLAIL,         140, 16,
            WPN_MORNING_STAR,   80, 16,
            WPN_HALBERD,        80, 10,
            WPN_BARDICHE,       80, 10,
            WPN_QUARTERSTAFF,   50, 10,
            WPN_SPEAR,          40, 6,
            WPN_JAVELIN,        60, 7,
            WPN_TRIDENT,        70, 12};

    log("Random Axe Maceish weapon");
    idxWpn := rnd(0,length(wpns)/3-1) * 3;

    u := createItem(weapon_name(wpns.[idxWpn]), ITEM_WEAPON, wpns.[idxWpn+1], 180, wpns.[idxWpn+2]);

    u.value[0] := wpns.[idxWpn]; // Set the weapon type
    u.manipulate := u.manipulate | MANIPULATE_WIELD;

    treasureize(u, bonuslvl, "matWpnBlade@randomt", "head//handle", "encWpnNew@randomt", "head//handle");

    return(u);
}
dilend



dilbegin unitptr createJewelry(bonuslvl : integer);
external
    unitptr treasureize(u : unitptr, bonuslvl : integer,
                             matDil : string, matArg : string, 
                             encDil : string, encArg : string);
    unitptr createItem(itemname : string,
                            item_type : integer, price : integer, size : integer, lbs : integer);
var
    u : unitptr;

    i : integer;
    s : string;
    sl : stringlist;
    wear : integer;
    price : integer;
code
{
    i := rnd(0,2);

    if (i == 0) // Ring
    {
        s := "ring";
        price := 1 * IRON_MULT;
        wear := MANIPULATE_WEAR_FINGER;
    }
    else if (i == 1) // necklace
    {
        price := 4 * IRON_MULT;
        s := "necklace";
        wear := MANIPULATE_WEAR_NECK;
    }
    else
    {
        price := 20 * IRON_MULT;
        sl := {"crown", "tiara"};
        i := rnd(0,1);
        s := sl.[i];
        wear := MANIPULATE_WEAR_HEAD;
    }

    // s is e.g. "ring" and wear would be MANIPULATE_WEAR_FINGER

    log("Random Jewelry");
    u := createItem(s, ITEM_TREASURE, price, 180, 0);
    u.manipulate := u.manipulate | wear;
    
    treasureize(u, bonuslvl, "matJewelry@randomt", "", "encJewelry@randomt", "");

    return(u);
}
dilend





// Consider this approach instead:
//   We receive the BONUS_LVL (0-7)
//   First we make rolls for:
//      Craftsmanship                       Enchantmenship
//      Main material (e.g. mithril blade) / Main enchantment (e.g. gold runes)
//      Secondary material (carved ivory) / secondary enchantment (diamond)
//
//      Maybe all rolls above are -3..+3, added to that the bonus level
//           {45,70,90} => 45% chance 0, 25% chance +1, 20% chance +2, 10% +3
//           -3 could be cursed
//      Result is [-3..10] -> 14 outcomes
//
//      Craftsmanship   : roll + bonuslvl, e.g. 7+2 =  9
//      Main material   : -1..1 + Craftsmanship, e.g. 9+1 =  10
//      Secondary mat   : -1..1 + Main mat e.g. 9 + 0 = 9
//
//      Enchantment     : roll + bonuslvl, e.g.  7+3 = 10
//      Main enc        : -1..1 + Enc, e.g.     10+1 =  10
//      Secondary enc   : roll + main mat   e.g. 9+0 = 9
//      Tertiary enc    : roll + main mat   e.g. 9+0 = 9
//
//     For weapons and armors:
//      Quality bonus = Craftsmanship*7/10
//      Enchantment bonus = Enchantment*7/10
//
// All these numbers are saved on the unit, e.g. in an extra or the title.
//
// Then after that, we generate the descriptions based on description tables.
//
// The downside to the above, is that silver can't be special in that it holds
// a lot of magic but gives a lower quality.



// ========================= OLD STUFF ==========================

// Genrate a random bladed weapon
//
// lvl : is 0-7 (BONUS_XXX) for power of weapon
// 
// Calls metalweapon with the three DILs
//   metalmats()
//   bladejob()
//   hiltjob()
// and metalweapon end up calling encWpn()
//
dilbegin unitptr rndblade(lvl : integer);
external
    unitptr metalweapon(bonuslvl : integer, wpnid : integer, 
                                 dflcost : integer, dflweight : integer, dflsize : integer,
                                 blade : string,
                                 hilt : string,
                                 materialdil : string,
                                 bladedil : string,
                                 hiltdil : string);

var
    u : unitptr;
    wpns : intlist;
    idxWpn : integer;
code
{
    log("Random sword");

    // weapon id, cost cp, weight
    wpns := {
            WPN_GREAT_SWORD,   200, 16,
            WPN_LONG_SWORD,    100, 8,
            WPN_BROAD_SWORD,   100, 8,
            WPN_CLAYMORE,      120, 9,
            WPN_SCIMITAR,      100, 7,
            WPN_FALCHION,       90, 9,
            WPN_SHORT_SWORD,    70, 6,
            WPN_RAPIER,         60, 4,
            WPN_MAIN_GAUCHE,    50, 2,
            WPN_STILETTO,       40, 1,
            WPN_DAGGER,         40, 1,
            WPN_SICKLE,         50, 2,
            WPN_SCYTHE,        100, 12
            };

    idxWpn := rnd(0,length(wpns)/3-1) * 3;

    return (metalweapon(lvl, wpns.[idxWpn], wpns.[idxWpn+1], wpns.[idxWpn+2], 170, "blade", "hilt", 
            "metalmats@randomt", "bladejob@randomt", "hiltjob@randomt"));
}
dilend



dilbegin unitptr rndheadshaft(lvl : integer);
external
    unitptr metalweapon(bonuslvl : integer, wpnid : integer, 
                                 dflcost : integer, dflweight : integer, dflsize : integer,
                                 blade : string,
                                 hilt : string,
                                 materialdil : string,
                                 bladedil : string,
                                 hiltdil : string);

var
    u : unitptr;
    wpns : intlist;
    idxWpn : integer;
code
{

    log("Random head / shaft");

    // weapon id, cost cp, weight
    wpns := {
            WPN_BATTLE_AXE,    160, 16,
            WPN_HAND_AXE,       60, 6,
            WPN_WAR_MATTOCK,    90, 10,
            WPN_ADZE,           70, 7,
            WPN_WAR_MAUL,       60, 9,
            WPN_WAR_HAMMER,     55, 7,
            WPN_BATTLE_CLUB,    50, 6,
            WPN_CLUB,           20, 4,
            WPN_BATTLE_MACE,    80, 12,
            WPN_MACE,           60, 6,
            WPN_FLAIL,         140, 16,
            WPN_MORNING_STAR,   80, 16,
            WPN_HALBERD,        80, 10,
            WPN_BARDICHE,       80, 10,
            WPN_QUARTERSTAFF,   50, 10,
            WPN_SPEAR,          40, 6,
            WPN_JAVELIN,        60, 7,
            WPN_TRIDENT,        70, 12};

    idxWpn := rnd(0,length(wpns)/3-1) * 3;

    return (metalweapon(lvl, wpns.[idxWpn], wpns.[idxWpn+1], wpns.[idxWpn+2], 170, "head", "shaft", 
            "metalmats@randomt", "bladejob@randomt", "hiltjob@randomt"));
}
dilend


dilbegin unitptr rndweapon(lvl : integer);
external
    unitptr rndheadshaft(lvl : integer);
    unitptr rndblade(lvl : integer);

code
{
    if (rnd(0,1) == 1)
        return (rndblade(lvl));
    else
        return (rndheadshaft(lvl));
}
dilend


%rooms

treasury

title "Test treasury"
descr
"You are in the treasury, its a huge square room with no exits. Apparently
the room is empty - obviously the treasures are beyond the reach of mere
mortals.

Bounce to generate a non-wood weapon."

flags {UNIT_FL_NO_WEATHER, UNIT_FL_INDOORS, UNIT_FL_NO_TELEPORT, UNIT_FL_NO_MOB}
ALWAYS_LIGHT

dilbegin bouncegenerator();
external
    unitptr createBladeHilt(lvl : integer);
    unitptr createJewelry(bonuslvl : integer);

var
    u : unitptr;
code
{
    :loop:
    wait(SFB_CMD, command("bounce"));
    log("BOUNCE RECEIVED");
    u := createBladeHilt(rnd(0,7));
    link(u, self);
    u := createJewelry(rnd(0,7));
    link(u, self);
    goto loop;
}
dilend

end


%objects

weapon_rnd
names {""}
title ""
descr ""
manipulate {MANIPULATE_TAKE}
end

treasure0
names {"treasure0"}
title "the tresure0 chest"
descr "treasure0 is here, open it"
open {EX_OPEN_CLOSE, EX_INSIDE_OPEN}
CONTAINER_DEF(10)

dilbegin treasure0();
external
    unitptr createBladeHilt(lvl : integer);

var 
    i : integer;
    u : unitptr;
code
{
    i := 0;
    while (i < 10)
    {
        u := createBladeHilt(BONUS_AVERAGE);
        link(u, self);
        i := i + 1;
    }
    quit;
}
dilend
end

treasure4
names {"treasure4"}
title "the tresure4 chest"
descr "treasure4 is here, open it"
CONTAINER_DEF(10)
open {EX_OPEN_CLOSE, EX_INSIDE_OPEN}

dilbegin treasure4();
external
    unitptr createBladeHilt(lvl : integer);
var 
    i : integer;
    u : unitptr;
code
{
    i := 0;
    while (i < 10)
    {
        u := createBladeHilt(BONUS_EXCELLENT);
        link(u, self);
        i := i + 1;
    }
    quit;
}
dilend
end

treasure7
names {"treasure7"}
title "the tresure7 chest"
descr "treasure7 is here, open it"
open {EX_OPEN_CLOSE, EX_INSIDE_OPEN}
CONTAINER_DEF(10)

dilbegin treasure7();
external
    unitptr createBladeHilt(lvl : integer);
var 
    i : integer;
    u : unitptr;
code
{
    log("TREASURE7");
    i := 0;
    while (i < 10)
    {
        u := createBladeHilt(BONUS_ARTIFACT);
        link(u, self);
        i := i + 1;
    }
    quit;
}
dilend
end

%reset

load treasure0 into treasury max 1
load treasure4 into treasury max 1
load treasure7 into treasury max 1

%end


//
// createBladeHilt() -> to create a frame unit for treasureize
//   treasureize()
//     calls treasureroll() -> to get all material bonuses, set cost, weight. Data in new extra "" created
//     calls param matDil
//         e.g. matWpnBlade() -> customized to set the weapon's blade materials and value[1] bonus
//                               also sets the hilt and hilt gem
//     calls param encDil
//         e.g. encWpn() -> customized to enchant a weapon and set value[2]
//


/*

*/