/*
filename    random
password    2kpwd
changedby   Papi
EmailAdd    Papi  <seifert@dikumud.com>
request     compile
version     1
END HEADER*/

#include <macros.h>


%zone		        randomt

lifespan 25
reset RESET_ANYHOW

creators {"papi"}

notes
"This zone is an attempt to make random treasure by Papi."


help
"Player should never be in here."


#define Q(x) #x
#define QUOTE(x) Q(x)

%dil

// il : intlist  [array of integers from 5..94]
//
// This funciton presume rolls of < 5 are a failure.
// This funciton presume rolls of > 95 are a open-ended success.
// The integers in the intlist are the number of bonuses, in the range
// 5..94 
//
// Example: [75,95]
//  Roll -30 = -1; Roll -80 = -2; Roll 74 = 0; Roll 75 = +1;
//  roll 94 = +1; roll 95 = +2; roll 144=+2; 145 = +3

dilbegin integer successroll(il : intlist);
var
    roll : integer;
    j : integer;
    m : integer;
code
{
    roll := openroll(100, 5);
    
    // Test if failure
    if (roll <= 4)
    {
        if (roll > -50)
            return (-1);
        else
            return ((roll / 50)-1);
    }

    j := 0;
    m := length(il);

    if (m < 1)
    {
        log("Illegal intlist in successroll()");
        quit;
    }

    while (j < m)
    {
        if (roll < il.[j])
            break;
        j := j + 1;
    }

    if (j < m)
        return (j); // First match = 0, second = +1, etc.

    // Roll is larger than last number in il

    return (m + (roll-il.[m-1])/50);
}
dilend


//
// max = length(list);
//
dilbegin integer bonuslistroll(il : intlist, bonuslvl : integer, max : integer);
external
    integer successroll(il : intlist);

var
    i : integer;
code
{

    i := successroll(il) + bonuslvl;
    if (i < 0)
        return (0);

    if (i >= max)
        return (max-1);

    return (i);
}
dilend


// Roll for the decor on the blade which can give room for more enchantments.
// And a nice description//
dilbegin integer hiltjob(u : unitptr, lvl : integer,  blade : string);
external
    integer successroll(il : intlist);
var 
    roll : integer;
    j : integer;
    sl : stringlist;    
    mats : stringlist;    
code
{
    // lvl is the smith roll outcome (typically 0-3 but OE)
    // u.value[1] is the smith and material bonus (up to max 7)
    // u.value[2] is the material enchantment (up to 5) plus smith bonus (usually 0-3, but Open ended)

    sl := {
        "Hilt decor minus 3 or less",
        "Hilt decor minus 2",
        "Hilt decor minus 1",
        "Hilt plain decor 0",
        "Hilt smooth decor 1",
        "Hilt engraved decor 2",
        "Hilt decor 3",
        "Hilt decor 4",
        "Hilt decor inlaid 5 + eng ",  // + Engraving mats
        "Hilt decor inlaid 6 + eng ",  // + Engraving mats
        "Hilt decor inlaid 7 + eng ",  // + Engraving mats
        "Hilt decor inlaid 8 + eng ",  // + Engraving mats
        "Hilt decor inlaid 9 + eng ",  // + Engraving mats
        "Hilt decor inlaid 10 + eng " // + Engraving mats
    };

    // Roll for the decoration, typically 0-3
    roll := successroll({50,75,85,95});
    log("Blade decor Roll = " + itoa(roll));

    j := u.value[2] + roll + 3;
    if (j >= length(sl))
        j := length(sl)-1;

    log("Hilt decor sum = " + itoa(j));
    log("Hilt decor: " + sl.[j]);

    if (j >= 8)
    {
        mats := { "pearl", "ruby", "diamond" };
        roll := rnd(0,2); // Pick random material
        u.value[2] := u.value[2] + roll + 1;
        log("Hilt Material : " + mats.[roll]);
        log("Hilt enchantment potential : " + itoa(u.value[2]));
        u.extra.descr := u.extra.descr + " " + sl.[j] + " in " + mats.[roll];
    }
    else
    {
        u.extra.descr := u.extra.descr + " " + sl.[j];
    }

    return (0);
}
dilend




// Roll for the decor on the blade which can give room for more enchantments.
// And a nice description//
dilbegin integer bladejob(u : unitptr, lvl : integer,  blade : string);
external
    integer successroll(il : intlist);
var 
    roll : integer;
    j : integer;
    sl : stringlist;    
    mats : stringlist;    
code
{
    // lvl is the smith roll outcome (typically 0-3 but OE)
    // u.value[1] is the smith and material bonus (up to max 7)
    // u.value[2] is the material enchantment (up to 5) plus smith bonus (usually 0-3, but Open ended)

    sl := {
        "Blade decor minus 3 or less",
        "Blade decor minus 2",
        "Blade decor minus 1",
        "Blade plain decor 0",
        "Blade smooth decor 1",
        "Blade engraved decor 2",
        "Blade decor 3",
        "Blade decor 4",
        "Blade decor inlaid 5 + eng ",  // + Engraving mats
        "Blade decor inlaid 6 + eng ",  // + Engraving mats
        "Blade decor inlaid 7 + eng ",  // + Engraving mats
        "Blade decor inlaid 8 + eng ",  // + Engraving mats
        "Blade decor inlaid 9 + eng ",  // + Engraving mats
        "Blade decor inlaid 10 + eng " // + Engraving mats
    };

    // Roll for the decoration, typically 0-3
    roll := successroll({50,75,85,95});
    log("Blade decor Roll = " + itoa(roll));

    j := u.value[2] + roll + 3;
    if (j >= length(sl))
        j := length(sl)-1;

    log("Blade decor sum = " + itoa(j));
    log("Blade decor: " + sl.[j]);

    if (j >= 8)
    {
        mats := { "silver", "gold", "platinum" };
        roll := rnd(0,2); // Pick random material
        u.value[2] := u.value[2] + roll + 1;
        log("Material : " + mats.[roll]);
        log("Blade enchantment potential : " + itoa(u.value[2]));
        u.extra.descr := u.extra.descr + " " + sl.[j] + " in " + mats.[roll];
    }
    else
    {
        u.extra.descr := u.extra.descr + " " + sl.[j];
    }

    return (0);
}
dilend


//
// Roll for the quality of the smith work baed on the material difficulty 
// and adjust the treasure level. Append a description.
//
// Returns the smith bonus. Typically +0 to +2, but since it is open ended can be anything
//
dilbegin integer smithjob(u : unitptr, bonuslvl : integer, matlvl : integer, enchant : integer, mat : string);
external
    integer successroll(il : intlist);
var 
    roll : integer;
    q : integer;
    sl : stringlist;
    
code
{
    log("Smith Level = " + itoa(bonuslvl) + "  Material difficulty = " + itoa(matlvl));

    //
    roll := successroll({40, 70, 90});
    roll := roll + (bonuslvl - matlvl);

    log("Smith roll = " + itoa(roll));

    // Adjust weapon quality
    q := u.value[1] + roll;
    if (q < -7)
        q := -7;
    if (q > 7)
        q := 7;
    u.value[1] := q;     

    log("New weapon quality is = " + itoa(q));

    // Enchantments potential
    u.value[2] := u.value[2] + roll; // +1,+2 gives more room for enchantment
    log("New weapon enchantment increased to = " + itoa(u.value[2]));

    // Get a smithing description based on weapons quality
    sl := {
        "Junk $2t $3t", // -7
        "Nearly junk $2t $3t",
        "Very terrible $2t $3t.",
        "Terrible $2t $3t",
        "Very bad $2t $3t.",
        "Bad $2t $3t.",
        "Below average $2t $3t.", 
        "Average $2t $3t.", // 0
        "Above average $2t $3t",
        "Good $2t $3t",
        "very good $2t $3t.",
        "Excellent $2t $3t.",
        "Above Excellent $2t $3t.",
        "Superior $2t $3t.",
        "Artifact $2t $3t." };

    log("weapon extra : " + sl.[u.value[1]+7]);
    u.extra.descr := sl.[u.value[1]+7];

    return (roll);
}
dilend



// Weapon id, cost, weight must be set before calling this
// Returns material level + smith level (not limited to -7 ...+7)
//
dilbegin integer metalmats(u : unitptr, lvl : integer, blade : string);
external
    integer smithjob@randomt(u : unitptr, bonuslvl : integer, matlvl : integer, enchant : integer, mat : string);
    integer bladejob@randomt(u : unitptr, lvl : integer,  blade : string);
    integer hiltjob@randomt(u : unitptr, lvl : integer,  blade : string);
    integer bonuslistroll@randomt(il : intlist, bonuslvl : integer, max : integer);

var
    materials : stringlist;
    idxMat : integer;
    i : integer;
    s : string;
    mat : string;
    smith : integer;
    enchantments : integer;
code
{
    // material, weight-index, value-index, enchantment capacity, bonus
    // Presuming the smithing material difficulty is equal to the mat bonus
    materials := {
        "copper",     "114",      "1", "0", QUOTE(BONUS_BAD),
        "bronze",     "110",     "10", "0", QUOTE(BONUS_AVERAGE_MINUS),
        "iron",       "100",    "100", "0", QUOTE(BONUS_AVERAGE), 
        "silver",     "133",   "1000", "3", QUOTE(BONUS_AVERAGE_PLUS),
        "steel",       "90",    "500", "1", QUOTE(BONUS_GOOD),
        "high steel",  "81",    "800", "1", QUOTE(BONUS_GOOD_PLUS),
        "black steel", "71",   "5000", "2", QUOTE(BONUS_EXCELLENT),
        "true steel",  "69",  "10000", "3", QUOTE(BONUS_EXCELLENT_PLUS),
        "adamantium",  "61",  "50000", "4", QUOTE(BONUS_SUPERIOR),
        "mithril",     "50", "100000", "5", QUOTE(BONUS_ARTIFACT) };

    // First roll for a random material based on bonuslvl
    // with [il] for BONUS_AVERAGE; 56% copper, 24% bronze, 9% iron, 5%+
    //               BONUS_ARTIFACT; 56% true steel, 24% adamantium, 14% mithril

    idxMat := bonuslistroll({60,85,95}, lvl, length(materials)/5) * 5;
    mat := materials.[idxMat];
    log("Material roll = " + itoa(idxMat/5) + " " + mat);

    // Set name, title, description, extra
    addstring(u.names, mat + " " + u.name);
    u.title := "a " + mat + " " + u.name;
    u.outside_descr := "a " + mat + " " + u.name + " is laying here.";
    // XXX Add extra

    // Adjust weight for material
    set_weight_base(u, (u.weight * atoi(materials.[idxMat+1]))/100);

    // Adjust the cost for material
    u.cost := (u.cost * atoi(materials.[idxMat+2]))/10000;

    // Set the material quality bonus
    u.value[1] := atoi(materials.[idxMat+4]);
    log("Material quality bonus = " + itoa(u.value[1]));

    // Set Enchantments potential
    u.value[2] := atoi(materials.[idxMat+3]); 
    log("Material enchantment potential = " + itoa(u.value[1]));

    // Make a smithy roll for the material and adjust
    smith := smithjob@randomt(u, lvl, atoi(materials.[idxMat+3]), u.value[2], mat);
    i := bladejob(u, smith, blade);
    i := hiltjob(u, smith,  blade);

    return (smith);
}
dilend


//
// ================= ENCHANTMENTS ===================
//


dilbegin enc_lightdark(u : unitptr, mod : integer);
code
{
    if (mod > 3)
    {
        mod := 3;
        log("enc_lightdark modifier too large ");
    }
    if (mod < -3)
    {
        mod := -3;
        log("enc_lightdark modifier too small ");
    }
    setbright(u, u.bright + mod);
    return;
}
dilend


//
// call with e.g. (u, ABIL_STR, BONUS_ARTIFACT)
//
dilbegin enc_ability(u : unitptr, abilid : integer, mod : integer);
var
  il : intlist;
code
{
    if (mod > BONUS_ARTIFACT)
    {
        mod := BONUS_ARTIFACT;
        log("enc_ability modifier too large ");
    }
    if (mod < BONUS_JUNK)
    {
        mod := BONUS_JUNK;
        log("enc_lightdark modifier too small ");
    }

    il := {-ID_RAISE_MAG, TIF_MAG_INC, TIF_MAG_DEC, 
           -ID_RAISE_DIV, TIF_DIV_INC, TIF_DIV_DEC, 
           -ID_RAISE_STR, TIF_STR_INC, TIF_STR_DEC, 
           -ID_RAISE_DEX, TIF_DEX_INC, TIF_DEX_DEC, 
           -ID_RAISE_CON, TIF_CON_INC, TIF_CON_DEC, 
           -ID_RAISE_CHA, TIF_CHA_INC, TIF_CHA_DEC, 
           -ID_RAISE_BRA, TIF_BRA_INC, TIF_BRA_DEC, 
           -ID_RAISE_HPP, TIF_HIT_INC, TIF_HIT_DEC    };
           
	addaff(u, il.[abilid*3], -1, 0,
	       abilid, mod, 0,
           il.[abilid*3+1], TIF_NONE, il.[abilid*3+2], APF_ABILITY);

    return;
}
dilend


// Make 4 ticks faster
dilbegin enc_haste(u : unitptr);
code
{
	addaff(u, ID_TRANSFER_SPEED, -1, 0,
	       SPEED_DEFAULT - SPEED_DEFAULT/3, 0, 0,
           TIF_SPEED_BETTER, TIF_NONE, TIF_SPEED_WORSE, APF_SPEED);

    return;
}
dilend


// Make 4 ticks slower
dilbegin enc_slow(u : unitptr);
code
{
	addaff(u, ID_TRANSFER_SPEED, -1, 0,
	       SPEED_DEFAULT+SPEED_DEFAULT/3, 0, 0,
           TIF_SPEED_WORSE, TIF_NONE, TIF_SPEED_BETTER, APF_SPEED);

    return;
}
dilend



dilbegin enc_goodprot(u : unitptr);
code
{
	addaff(u, ID_PROT_GOOD_TRANSFER, -1, 0,
	       0, 0, 0,
           TIF_PROT_GOOD_ON, TIF_NONE, TIF_PROT_GOOD_OFF, APF_NONE);

    return;
}
dilend


dilbegin enc_evilprot(u : unitptr);
code
{
	addaff(u, ID_PROT_EVIL_TRANSFER, -1, 0,
	       0, 0, 0,
           TIF_PROT_EVIL_ON, TIF_NONE, TIF_PROT_EVIL_OFF, APF_NONE);

    return;
}
dilend


dilbegin integer enchant(u : unitptr, lvl : integer, blade : string);
external
    enc_lightdark(u : unitptr, mod : integer);
    enc_ability(u : unitptr, abilid : integer, mod : integer);
    enc_haste(u : unitptr);
    enc_slow(u : unitptr);
    enc_goodprot(u : unitptr);
    enc_evilprot(u : unitptr);

code
{
    log("here we're supposed to enchant the weapon");
    //enc_lightdark(u, 1);
    //enc_ability(u, ABIL_MAG, -1);
    //enc_ability(u, ABIL_DIV,  1);
    //enc_ability(u, ABIL_STR,  2);
    //enc_ability(u, ABIL_DEX,  3);
    //enc_ability(u, ABIL_CON,  4);
    //enc_ability(u, ABIL_CHA,  5);
    //enc_ability(u, ABIL_BRA,  6);
    //enc_ability(u, ABIL_HP,  7);
    enc_haste(u);
    //enc_slow(u);
    //enc_goodprot(u);
    //enc_evilprot(u);
    return (0);
}
dilend

// For generating metal weapons with hilts / shafts such as swords, axes, 
// maces, tridents, spears, javelins, etc.
//
// bonuslvl    : BONUS_XXX (0-7) of the quality of weapon to create
// wpnid       : WPN_XXX type of weapon to create, e.g. WPN_JAVELIN
// dflcost     : Default cost of the weapon if it was made in iron
// dflweight   : Default weight of the weapon
// dflsize     : Default size of the weapon (170cm?)
// materialdil : the DIL to generate the material
// bladedil    : the DIL to process the blade / point / head of the weapon
// hiltdil     : the DIL to process the hilt / shaft of the weapon
//
dilbegin unitptr metalweapon(bonuslvl : integer, wpnid : integer, 
                                 dflcost : integer, dflweight : integer, dflsize : integer,
                                 materialdil : string,
                                 bladedil : string,
                                 hiltdil : string);

external
    integer enchant(u : unitptr, lvl : integer, blade : string);

var
    u : unitptr;
    wpns : stringlist;
    i : integer;
    s : string;
    t : string;
    smith : integer;
    enchantments : integer;
code
{
    u := load("weapon_rnd@randomt");
    if (u == null)
    {
        log("Unable to load basis weapon");
        quit;
    }

    u.value[0] := wpnid;
    s := weapon_name(wpnid);
    u.names.[0] := s;

    // add a placeholder for appending descriptions 
    addextra(u.extra, {""}, "");

    set_weight_base(u, dflweight);
    u.height := dflsize;
    u.cost := dflcost;

    // Find primary weapon material and smith job, gets 
    i := dilcall(materialdil)(u, bonuslvl, "blade"); 

    if (u.value[2] > 0)
        u.flags := u.flags | UNIT_FL_MAGIC;

    i := enchant@randomt(u, bonuslvl, "blade");

    return(u);
}
dilend



//
// Enchantments:
//   Magic bonus
//   Ability transfer (8)
//   Good / Evil protection
//   Resistance (spell categories)
//   Defense (weapon categories)
//   
//   Possible expansions
//     Weapon has embedded spells that can be used X times / day
//     Extra Fire, Cold, Electricity, damage or blade type - how?


// Level is 0-7 (BONUS_XXX) for power of weapon

dilbegin unitptr generateweapon(lvl : integer);
external
    integer bladequality(lvl : integer);

var
    u : unitptr;
    wpns : stringlist;
    materials : stringlist;
    idxWpn : integer;
    idxMat : integer;
    i : integer;
    s : string;
    t : string;
    smith : integer;
    enchantments : integer;
code
{
    log("WEAPON MAKER");
    heartbeat := PULSE_SEC * 4;
    // weapon name, weapon id, cost cp, weight
    wpns := {
            QUOTE(WPN_BATTLE_AXE),    "160", "16",
            QUOTE(WPN_HAND_AXE),       "60", "6",
            QUOTE(WPN_WAR_MATTOCK),    "90", "10",
            QUOTE(WPN_ADZE),           "70", "7",
            QUOTE(WPN_WAR_MAUL),       "60", "9",
            QUOTE(WPN_WAR_HAMMER),     "55", "7",
            QUOTE(WPN_BATTLE_CLUB),    "50", "6",
            QUOTE(WPN_CLUB),           "20", "4",
            QUOTE(WPN_BATTLE_MACE),    "80", "12",
            QUOTE(WPN_MACE),           "60", "6",
            QUOTE(WPN_FLAIL),         "140", "16",
            QUOTE(WPN_MORNING_STAR),   "80", "16",
            QUOTE(WPN_GREAT_SWORD),   "200", "16",
            QUOTE(WPN_LONG_SWORD),    "100", "8",
            QUOTE(WPN_BROAD_SWORD),   "100", "8",
            QUOTE(WPN_CLAYMORE),      "120", "9",
            QUOTE(WPN_SCIMITAR),      "100", "7",
            QUOTE(WPN_FALCHION),       "90", "9",
            QUOTE(WPN_SHORT_SWORD),    "70", "6",
            QUOTE(WPN_RAPIER),         "60", "4",
            QUOTE(WPN_MAIN_GAUCHE),    "50", "2",
            QUOTE(WPN_STILETTO),       "40", "1",
            QUOTE(WPN_DAGGER),         "40", "1",
            QUOTE(WPN_SICKLE),         "50", "2",
            QUOTE(WPN_HALBERD),        "80", "10",
            QUOTE(WPN_BARDICHE),       "80", "10",
            QUOTE(WPN_SCYTHE),        "100", "12",
            QUOTE(WPN_QUARTERSTAFF),   "50", "10",
            QUOTE(WPN_SPEAR),          "40", "6",
            QUOTE(WPN_JAVELIN),        "60", "7",
            QUOTE(WPN_TRIDENT),        "70", "12"};


    // material, weight-index, value-index, enchantment capacity, bonus
    materials := {
        "copper",     "114",      "1", "0", QUOTE(BONUS_BAD_MINUS),
        "bronze",     "110",     "10", "0", QUOTE(BONUS_AVERAGE_MINUS),
        "iron",       "100",    "100", "0", QUOTE(BONUS_AVERAGE), 
        "silver",     "133",   "1000", "3", QUOTE(BONUS_AVERAGE_PLUS),
        "steel",       "90",    "500", "1", QUOTE(BONUS_GOOD),
        "high steel",  "81",    "800", "1", QUOTE(BONUS_GOOD_PLUS),
        "black steel", "71",   "5000", "2", QUOTE(BONUS_EXCELLENT),
        "true steel",  "69",  "10000", "3", QUOTE(BONUS_EXCELLENT_PLUS),
        "adamantium",  "61",  "50000", "4", QUOTE(BONUS_SUPERIOR),
        "mithril",     "50", "100000", "5", QUOTE(BONUS_ARTIFACT) };

    idxWpn := rnd(0,30) * 3;
    idxMat := rnd(0,9) * 5;

    u := load("weapon_rnd@randomt");
    if (u != null)
        log("loaded a weapon");

    t := materials.[idxMat];
    log("Material roll = " + itoa(idxMat / 4));
    log("Material = " + t);
    s := weapon_name(atoi(wpns.[idxWpn]));

    addstring(u.names, t + " " + s);
    addstring(u.names, s);
    u.title := "a " + t + " " + s;
    u.outside_descr := "a " + t + " " + s + " is laying here.";

    // Calculate and set the weight
    i := (atoi(wpns.[idxWpn+2]) * atoi(materials.[idxMat+1]))/100;
    set_weight_base(u, i);

    // Calculate and set the cost
    i := (atoi(wpns.[idxWpn+1]) * atoi(materials.[idxMat+2]))/10000;
    u.cost := i;

    u.value[0] := atoi(wpns.[idxWpn]);

    // Get the material bonus
    i := atoi(materials.[idxMat+4]);
    log("Material quality bonus = " + itoa(i));
 
    // Get the quality of the smith work
    smith := bladequality(lvl);
    log("Smith quality bonus = " + itoa(smith));

    //
    // Calculate number of enchantments
    //
    log("Enchantments = " + itoa(enchantments));
    enchantments := smith + atoi(materials.[idxMat+3]);
 
    smith := smith + i;
    if (smith > 7)
        smith := 7;
    if (smith < -7)
        smith := -7;

    log("Final quality bonus = " + itoa(smith));

    u.value[1] := smith;

    return(u);
}
dilend



%rooms

treasury

title "Test treasury"
descr
"You are in the treasury, its a huge square room with no exits. Apparently
the room is empty - obviously the treasures are beyond the reach of mere
mortals.

Bounce to generate a non-wood weapon."

flags {UNIT_FL_NO_WEATHER, UNIT_FL_INDOORS, UNIT_FL_NO_TELEPORT, UNIT_FL_NO_MOB}
ALWAYS_LIGHT

dilbegin bouncegenerator();
external
    unitptr generateweapon(lvl : integer);
    unitptr metalweapon@randomt(bonuslvl : integer, wpnid : integer, 
                                 dflcost : integer, dflweight : integer, dflsize : integer,
                                 materialdil : string,
                                 bladedil : string,
                                 hiltdil : string);
var
    u : unitptr;
code
{
    heartbeat := PULSE_SEC * 4;

    :loop:
    wait(SFB_CMD, command("bounce"));
    log("BOUNCE RECEIVED");
    u := metalweapon@randomt(BONUS_ARTIFACT, WPN_BATTLE_AXE, 160, 16, 180, 
                                 "metalmats@randomt",
                                 "",
                                 "");
    link(u, self);
    goto loop;
}
dilend

end


%objects

weapon_rnd
names {""}
WEAPON_DEF(WPN_DAGGER, BONUS_AVERAGE, BONUS_AVERAGE)
title ""
descr ""
end


%end
