#include <macros.h>

/*
   Next step:
      Update join guild and more.
*/

%zone guilds

reset RESET_NOT

creators {"Papi"}

notes "The DIL functions needed to manage Guilds."

help 
"MS 2022. High level description of guilds.<br/>

When a player first joins the game they choose a profession.
The profession automatically enrolls them in a guild matching
the profession.<br/>

Some guilds exclude other guilds. For example you cannot become
a Paladin if you're in the Necromancer, Thief or Dark Knight guilds.<br/>

A player can thereafter join as many guilds as they want. Joining a 
guild should require something from the player, e.g. completing a quest.<br/>

Training cost is determined by the player's profession, so joining a new
guild will not make it cheaper to practice e.g. your strength, but new
guilds and teachers might offer training in skills not in your current guild
or even have higher maximums than your current guild.<br/>

Along with this we will also introduce the ability to switch profession
when you reach level 50. For example from a fighter to a mage. This will
allow you to make a combination character as you build up to level 100 and beyond.
E.g. Fighter / Mage.

The data structure is as follows:

pc.guild
   Holds the GUILD_ string of the player's current 'default' guild.

pc.info
   Has the following entry for each guild that the player is a member of:

   {'$guild/paladin', '7', '50', '$guild'}

   .[0] is the guild name prepended with '$guild/'
   .[1] is the current guild level
   .[2] was the player's vlvl when the joined the guild. 
   .[3] is the guild string (I considered prepending $g_ but will just try this)
        (in case we need to iterate throught them all)
"


%dil

//
// Guild Masters:
//    Except for your starting guild, you join new guilds at the guild master.
//
// DIL setup:
//    [nokill]
//         - optional DIL to avoid having guild members murdered.
//    quest blocking DIL(s)
//         - e.g. QuestBlock@guilds(); you can only join if you completed X
//    join DIL
//         - We're missing a generic join DIL I think.
//         - e.g. master_join@paladin_guild
//
//     MurderBanish()  (replaces SFUN_GUILD_BASIS)
//        - Any player killing a guild master / teacher will get banished
//
//     AlertMembers()  (replaces SFUN_GUILD_BASIS)
//        - Alert guild members that guild is under attack
//
//     guild_titles@guild_paths()


// Guild teachers:
//   Offer teachings, abilities, skills, spells, weapons that you can practice.
//
// - setup:

// #define _WEAPON
// #include "guilddef.h"
// #undef _WEAPON
//

//
// =================================================================
//

// Plan:
//   in block.zon ?
//
// QuestBlock@guilds(cmd : string, quest : string, sExec : stringlist);
//    used to blocks the join command unless player has list of quests
//
// alignment@block - 
//    blocks the join command unless player has alignment GOOD, EVIL or NEUTRAL
//
// guild@block({commands}, guild, {actions}) - 
//    used to block player {commands} unless the player is in the guild
// 
// move@block({directions}, guild, {actions}) - 
//    used to block player moving in direction unless the player is in the guild
// 
// guild_wield()
//    if not in guild, unequip and drop
//

//
// =================================================================
// New guild helper functions per 2022 MS to add / remove
// guilds from player's info.
//
// integer IsInGuild@guilds(pc : unitptr, sGuild : string);
// integer IsInGuilds@guilds(pc : unitptr, sGuilds : stringlist);
// integer IsBanished@guilds(pc : unitptr, sGuild : string);
// string GuildString@guilds(pc : unitptr);
// string GuildStrings@guilds(pc : unitptr);
// JoinGuild@guilds(pc : unitptr, sGuild : string);
// LeaveGuild@guilds(pc : unitptr, sGuild : string);
// BanishGuild@guilds(pc : unitptr, sGuild : string);
// MurderBanish@guilds(sGuild : string);
// AlertMembers@guilds(sGuild : string, sMsg : string);

//
// Blockers:
// TrainMemberChk(sGuild : string, sMsg : string);
// QuestBlock(cmd : string, quest : string, sExec : stringlist);
//
// SetAutoTrain(pc : unitptr, sGuild : string);
// AdvGuildLevel(ch : unitptr);


#define GUILD_PREPEND   "$guild/"
#define GUILD_BANISHED  "$guilds_ban"
#define GUILD_LEFT      "$guilds_left"


// Checks if player pc is in guild sGuild
// 0 = not in guild, 1 = in guild
//
dilbegin string GuildString(pc : unitptr);
code
{
   return (pc.guild);
}
dilend


// Checks if player pc is in guild sGuild
// 0 = not in guild, 1 = in guild
//
dilbegin integer IsInGuild(pc : unitptr, sGuild : string);
var
   exd : extraptr;
code
{
   exd := (GUILD_PREPEND + sGuild) in pc.info;

   if (exd == null)
      return (0);

   return (1);
}
dilend


// Checks if player pc is in any of the guilds in 'sGuilds'
// 0 = not in any of the guild, 1 = in one of the guilds
//
dilbegin integer IsInGuilds(pc : unitptr, sGuilds : stringlist);
var
   ln : integer;

code
{
   ln := length(sGuilds) - 1;
   while (ln >= 0)
   {
      if ((GUILD_PREPEND+sGuilds.[ln]) in pc.info)
         return (1);

      ln := ln-1;
   }

   return (0);
}
dilend


// Checks if player pc is in guild sGuild
// 0 = not in guild, 1 = in guild
//
dilbegin integer IsBanished(pc : unitptr, sGuild : string);
var
   exd : extraptr;
code
{
   exd := GUILD_BANISHED in pc.info;

   if (exd == null)
      return (0);

   if ((GUILD_PREPEND + sGuild) in exd.names)
      return (1);

   return (0);
}
dilend


// Joins player pc to guild sGuild
//
dilbegin JoinGuild(pc : unitptr, sGuild : string);
var
   exd : extraptr;
   sl : stringlist;
code
{
   sGuild := GUILD_PREPEND+sGuild;

   exd := sGuild in pc.info;

   if (exd)
   {
      log("Error in JoinGuild. Guild was already in player guild list");
      return;
   }

   addstring(sl, sGuild);
   addstring(sl, "0");
   addstring(sl, itoa(pc.vlevel));
   addstring(sl, "$guild");
   
   addextra(pc.info, sl, "");

   return;
}
dilend


// Player pc leaves the guild sGuild (moved to GUILD_LEFT)
//
dilbegin LeaveGuild(pc : unitptr, sGuild : string);
var
   exd : extraptr;
   exdleft : extraptr;
code
{
   exd := (GUILD_PREPEND + sGuild) in pc.info;

   if (exd == null)
   {
      log("Error in LeaveGuild. $guild to leave not found for " + pc.name);
      return;
   }

   subextra(pc.info, GUILD_PREPEND + sGuild);

   // Now add to GUILD_LEFT

   exdleft := GUILD_LEFT in pc.info;

   if (exdleft == null)
   {
      addextra(pc.info, {GUILD_LEFT}, "");
      exdleft := GUILD_LEFT in pc.info;
   }

   if (sGuild in exdleft.names)
   {
      log("Error in LeaveGuild. The guild was already left for : " + pc.name);
      return;
   }

   addstring(exdleft.names, sGuild);
   return;
}
dilend


// Player pc is banished from his guild sGuild (moved to GUILD_BANISHED)
// If player is not in the guild, they are still added as banished.
//
dilbegin BanishGuild(pc : unitptr, sGuild : string);
var
   exd : extraptr;
   exdbanished : extraptr;
code
{
   exd := (GUILD_PREPEND + sGuild) in pc.info;

   if (exd)
   {
      subextra(pc.info, GUILD_PREPEND + sGuild);
   }

   exdbanished := GUILD_BANISHED in pc.info;

   if (exdbanished == null)
   {
      addextra(pc.info, {GUILD_BANISHED}, "");
      exdbanished := GUILD_BANISHED in pc.info;
   }

   if (not (sGuild in exdbanished.names))
   {
      // Banish the player, regardless if they're a member or not.
      addstring(exdbanished.names, sGuild);
   }

   return;
}
dilend


// =================================================================
// Replacing SFUN_GUILD_BASIS

// kill_banish
// Purpose: If someone attacks a guild master, make them banished,
//    even if they are not members.
//
dilbegin fnpri(FN_PRI_BLOCK-2) MurderBanish(sGuild : string);
external
   BanishGuild@guilds(pc : unitptr, sGuild : string);

var
   u : unitptr;

code
{
:loop:
   wait(SFB_DEAD, self == activator);

   u := self.outside;

   while (u)
   {
      if ((u.type == UNIT_ST_PC) and (u.fighting == self) and (visible(self, u)))
      {
         BanishGuild@guilds(u, sGuild);
      }
      u := u.next;
   }

   goto loop;
}
dilend



// Alert all guild members if guild is under attack
//    NOT YET IMPLEMENTED
dilbegin fnpri(FN_PRI_BLOCK-2) AlertMembers(sGuild : string, sMsg : string);
external
   BanishGuild@guilds(pc : unitptr, sGuild : string);
var
   s : string;
code
{
   heartbeat := PULSE_SEC * 60;

:loop:
   wait(SFB_COM, TRUE);

    if (self.fighting)
    {
       if (sMsg == "")
         sMsg := "$3n tells you, 'Help! Our guild is attacked by $1n'";

      s := sact(sMsg, A_SOMEONE, self.fighting, null, self, TO_CHAR);

      // Need to write code to send to guild members. Use Channels? XXX

      pause;
    }

     goto loop;
}
dilend


// =================================================================
// quest@block(cmd, quest, {exec}) - 
//    If a char does the command 'cmd':
//       Allow command if char has the quest 'quest'
//       block it otherwise
//
// Sample: 
//    dilcopy QuestBlock@guilds("join", WIGHT_COMPLETE, {"say If you wish to join you must prove yourself worthy by completing the Wight Warren's quest"});
//
//    The player can only join if they have completed the WIGHT_COMPLETE quest.
//

dilbegin fnpri(FN_PRI_BLOCK-1) QuestBlock(cmd : string, quest : string, sExec : stringlist);
external
   Explainer@quests(pc : unitptr, sl : stringlist);

code
{
:loop:
   wait(SFB_CMD, command(cmd));

   if (not (quest in activator.quests))
   {
      block;
      Explainer@quests(activator, sExec);
   }

   goto loop;
}
dilend



dilbegin fnpri(FN_PRI_BLOCK+1) TrainMemberChk(sGuild : string, sMsg : string);
external
   integer IsInGuild@guilds(pc : unitptr, sGuild : string);
var
  pc   : unitptr;
code
{
:start:
   wait (SFB_CMD, command ("practice") and (activator.type == UNIT_ST_PC));

   if (not IsInGuild@guilds(activator, sGuild))
   {
      block;
      if ((self.position > POSITION_SLEEPING) or (self.position != POSITION_FIGHTING))
      {
         if (sMsg == "")
            sMsg := "say You're not a member of our guild, go speak with the guild master.";
         exec(sMsg, self);
      }
   }
   goto start;
}
dilend



// =================================================================

// Call this to set the auto-train values to the guild name given
//
dilbegin SetAutoTrain(pc : unitptr, sGuild : string);
var
   sl : stringlist;
code
{
   if (sGuild == GUILD_UDG_FIGHTER)
      sl := {"$autotrain", GUILD_UDG_FIGHTER_ATL};
   else if (sGuild == GUILD_KNIGHT)
      sl := {"$autotrain", GUILD_KNIGHT_ATL};
   else if (sGuild == GUILD_PALADIN)
      sl := {"$autotrain", GUILD_PALADIN_ATL};
   else if (sGuild == GUILD_NYM_RANGER)
      sl := {"$autotrain", GUILD_RANGER_ATL};
   else if (sGuild == GUILD_UDG_THIEF)
      sl := {"$autotrain", GUILD_THIEF_ATL};
   else if (sGuild == GUILD_ASSASSIN)
      sl := {"$autotrain", GUILD_ASSASSIN_ATL};
   else if (sGuild == GUILD_UDG_CLERIC)
      sl := {"$autotrain", GUILD_CLERIC_ATL};
   else if (sGuild == GUILD_NYM_DRUID)
      sl := {"$autotrain", GUILD_DRUID_ATL};
   else if (sGuild == GUILD_NECROMANCER)
      sl := {"$autotrain", GUILD_NECROMANCER_ATL};
   else if (sGuild == GUILD_UDG_MAGE)
      sl := {"$autotrain", GUILD_MAGE_ATL};
   else if (sGuild == GUILD_SORCERER)
      sl := {"$autotrain", GUILD_SORCERER_ATL};
   else if (sGuild == GUILD_BARBARIAN)
      sl := {"$autotrain", GUILD_BARBARIAN_ATL};
   else
   {
      log("ERROR: setautotrain: invalid sGuild");
      return;
   }

   subextra(pc.quests, "$autotrain");
   addextra(pc.quests, sl, "");
   return;
}
dilend



// Set / changes the player's current default guild.
// Also sets up the Auto-train.
// The player must already be in the guild for this
// to work.
//
dilbegin SetDefaultGuild(pc : unitptr, sGuild : string);
external
   SetAutoTrain(pc : unitptr, sGuild : string);
var
   exd : extraptr;
code
{
   exd := sGuild in pc.info;

   if (exd == null)
   {
      log("Error setting ["+sGuild+"] as the new default for player: "+pc.name);
      return;
   }

   pc.guild := sGuild;
   SetAutoTrain(pc, sGuild);
   return;
}
dilend


dilbegin AdvGuildLevel(pc : unitptr);
var
   exd : extraptr;
   s : string;
code
{
   exd := (GUILD_PREPEND + pc.guild) in pc.info;

   if (exd == null)
   {
      log("Error in AdvGuildLevel(): Unable to find ["+pc.guild+"] in pc.info");
      return;
   }

   s := itoa(1+atoi(exd.names.[1]));
   exd.names.[1] := s;
   return;
}
dilend


// Returns the level of the player's guild 'sGuild'
// -1 if no such guild found
//
dilbegin integer GetGuildLevel(pc : unitptr, sGuild : string);
var
   exd : extraptr;
code
{
   exd := (GUILD_PREPEND + sGuild) in pc.info;

   if (exd == null)
      return (-1);

   return (atoi(exd.names.[1]));
}
dilend



dilbegin SetTitles(the_guild : string, title_list : stringlist);
external
   integer GetGuildLevel(pc : unitptr, sGuild : string);
   SetDefaultGuild(pc : unitptr, sGuild : string);
var
   ln:integer;
   male_list    : stringlist;
   female_list  : stringlist;
   pc           : unitptr;
   pclevel      : integer;
   pcsex        : integer;
   i            : integer;
   newtit       : string;
   my_race      : string;

code
{
:init:
   /* Sort the list into two different lists and add gaps for even levels */
   addstring(male_list, "-");
   addstring(female_list, "-");

   i := 0;
   ln:=length(title_list);
   while(i < ln)
   {
      addstring(male_list, title_list.[i]);
      if (i+1<ln)
         addstring(female_list, title_list.[i+1]);
      i := i + 2;
   }


:start:
   wait(SFB_CMD, command("title") and (activator.level < 235) and (activator.type == UNIT_ST_PC));
   pc := activator;
   secure(pc, lost_pc);
   SetDefaultGuild(pc, the_guild);

:do_title:
   pcsex   := pc.sex;
   if (pc.race == RACE_HUMAN)
      my_race := "Human";
   else if (pc.race == RACE_ELF)
      my_race := "Elf";
   else if (pc.race == RACE_DWARF)
      my_race := "Dwarf";
   else if (pc.race == RACE_HALFLING)
      my_race := "Halfling";
   else if (pc.race == RACE_GNOME)
      my_race := "Gnome";
   else if (pc.race == RACE_HALF_ORC)
      my_race := "Half-Orc";
   else if (pc.race == RACE_HALF_OGRE)
      my_race := "Half-Ogre";
   else if (pc.race == RACE_HALF_ELF)
      my_race := "Half-Elf";
   else if (pc.race == RACE_BROWNIE)
      my_race := "Brownie";
   else if (pc.race == RACE_GROLL)
      my_race := "Groll";
   else
      my_race := "Darkelf";

   pclevel := GetGuildLevel(pc, the_guild);
   pclevel := pclevel/5;

   if (pcsex < 2)
   {
      if (pclevel>(length(male_list)-1))
         pclevel:=(length(male_list)-1);
      newtit := male_list.[pclevel];
   }
   else
   {
      if (pclevel>(length(female_list)-1))
         pclevel:=(length(female_list)-1);
      newtit := female_list.[pclevel];
   }

   if (newtit == "-")
   {
      if (pcsex < 2)
      {
         if (pclevel<1)
            goto jumpbug;
         if (not(male_list.[pclevel - 1] in pc.title))
         {
            exec("say Enjoy the title, " + pc.name + "!", self);
            pc.title := "the " + my_race + " " + male_list.[pclevel - 1];
            goto lost_pc;
         }
         else
         {
            :jumpbug:
            exec("say You need to attain a higher level before you " +
                 "can receive a new title, " + pc.name + ".", self);
            goto lost_pc;
         }
      }
      else if (pcsex > 1)
      {
         if (pclevel<1)
            goto jumpbug2;

         if (not(female_list.[pclevel - 1] in pc.title))
         {
            exec("say Enjoy the title, " + pc.name + "!", self);
            pc.title := "the " + my_race + " " + female_list.[pclevel - 1];
            goto lost_pc;
         }
         else
         {
            :jumpbug2:
            exec("say You need to attain a higher level before you " +
                 "can receive a new title, " + pc.name + ".", self);
            goto lost_pc;
         }
      }
   }
   else if (newtit in pc.title)
   {
      exec("say You have already attained the appropriate title for " +
           "this guild level, " + pc.name + ".", self);
      goto lost_pc;
   }
   else
   {
      pc.title := "the " + my_race + " " + newtit;
      exec("say Enjoy the title, " + pc.name + "!", self);
      goto lost_pc;
   }

:lost_pc:
   unsecure(pc);
   goto start;
}
dilend /* guild_titles */


%end
