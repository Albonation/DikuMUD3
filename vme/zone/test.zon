/*
filename    test
password    screwloose
changedby   Whistler
EmailAdd     HTMLCOMPILED
request     compile
version     1
END HEADER*/

#include <macros.h>


%zone                                  test

   reset RESET_NOT
   weather 1040
   creators {"papi"}

   notes
   "This is a test zone. Can we do DIL 'unit testing' ?"

   help
   "This zone is not intended for players."

%dil

#define LOGT_ERROR   0
#define LOGT_SUCCESS 1
#define LOGT_INFO    2


dilbegin logtest(no : integer, ltype : integer, msg : string);
var
   sl : stringlist;
code
{
   sl := {"ERROR", "SUCCESS", "INFO"};
   log("T"+itoa(no)+"//"+sl.[ltype]+" "+msg);
   return;
}
dilend

dilbegin followdil();
external
   logtest(no : integer, ltype : integer, msg : string);

var
   u : unitptr;
code
{
   exec("follow experiment", self);
   exec("stand", self);
   if (self.master == null)
      logtest(1, LOGT_ERROR, "Unable to follow");
   else
      logtest(1, LOGT_INFO, "Following: " + self.master.name);

   u := self.master;
   secure(u, lostit);
   heartbeat := PULSE_SEC * 4;

:loop:
   pause;
   if (u == null)
   {
      logtest(1, LOGT_ERROR, "u turned to null.");
      quit;
   }
   logtest(1, LOGT_INFO, "Follower has master secured()");
   goto loop;

:lostit:
   logtest(1, LOGT_ERROR, "Follower lost master.");
   quit;
}
dilend

dilbegin walkeast();
external
   integer walk_room@function(place:string, spd:integer);
var
   u : unitptr;
   i : integer;
code
{
   heartbeat := PULSE_SEC;
   pause;
   u := findunit(self, "follower", FIND_UNIT_SURRO, null);
   if (u == null)
   {
      log("Error: unable to find follower");
      quit;
   }
   secure(u, lostpc);

   log("T001//Info TEST STARTING");

   log("T001//Info in room: "+self.outside.symname);
   exec("east", self);
   log("T001//Info in room: "+self.outside.symname);
   pause;
   if (u == null)
   {
      log("T001//ERROR: secure(u) null after exec() one");
      quit;
   }
   if (u.outside != self.outside)
   {
      log("T001//ERROR: follower not in the same room as master");
      quit;
   }

   exec("east", self);
   log("T001//Info in room: "+self.outside.symname);
   pause;
   if (u == null)
   {
      log("T001//ERROR: secure(u) null after exec() two");
      quit;
   }
   if (u.outside != self.outside)
   {
      log("T001//ERROR: follower not in the same room as master");
      quit;
   }

   pause;
   exec("east", self);
   log("T001//Info in room: "+self.outside.symname);
   pause;
   if (u == null)
   {
      log("T001//ERROR: secure(u) null after exec() three");
      quit;
   }
   if (u.outside != self.outside)
   {
      log("T001//ERROR: follower not in the same room as master");
      quit;
   }

   pause;
   log("T001//Info FIRST WALK_ROOM to labc");
   i := walk_room@function("testlabc@test", PULSE_SEC);
   log("T001//Info in room: "+self.outside.symname);
   pause;
   if (u == null)
   {
      log("T001//ERROR: secure(u) null after exec() three");
      quit;
   }
   if (u.outside != self.outside)
   {
      log("T001//ERROR: follower not in the same room as master");
      quit;
   }

   log("T001//Info SECOND WALK_ROOM to labe");
   i := walk_room@function("testlabe@test", PULSE_SEC);
   log("T001//Info in room: "+self.outside.symname);
   if (u == null)
   {
      log("T001//ERROR secure(u) null after exec() five");
      quit;
   }
   if (u.outside != self.outside)
   {
      log("T001//ERROR: follower not in the same room as master");
      quit;
   }
   pause;

   log("T001//SUCCESS");
   quit;

:lostpc:
   log("T001//ERROR Triggered secure() not supposed to happen");
   quit;
}
dilend


// Setup test 001
dilbegin T001();
var
   u1, u2 : unitptr;

code
{
   u1 := load("experiment@test");
   link(u1, findroom("testlabc@test"));

   u2 := load("follower@test");
   link(u2, findroom("testlabc@test"));

   dilcopy("followdil@test()", u2);
   dilcopy("walkeast@test()", u1);

   // Here we need to wait for it to either finish
   // or a timer will trigger and fail the test.

   quit;
}
dilend



dilbegin integer buglostint(pc : unitptr, ip : integer, s : string);
code
{
   secure(pc, lostpc);

   :loop:
   wait(SFB_CMD, 1==1);
   goto loop;

   :lostpc:
   log("Lost PC in called function integer.");
   return(0);
}
dilend


dilbegin unitptr buglostpc(pc : unitptr);
external
   integer buglostint(pc : unitptr, ip : integer, s : string);


var
  i : integer;
code
{
   secure(pc, lostpc);

   :loop:
   i := buglostint(pc, 42, "42");
   if (pc == null)
      log("PC is null");
   else
      log(pc.name);
   wait(SFB_CMD, 1==1);
   goto loop;

   :lostpc:
   exec("emote loses its grip.", self);
   log("Lost PC in called function.");
   pc := null;
   return(pc);
}
dilend



%rooms

                                   testlabc

title "Test Laboratory Center"
descr
"   You are in the first test laboratory."
flags {UNIT_FL_NO_WEATHER}
light 5
east to testlabe;

dilcopy T001@test();
end

                                   testlabe

title "Test Laboratory East"
descr
"   You are in the first test laboratory."
flags {UNIT_FL_NO_WEATHER}
light 5
west to testlabc;
east to testlabc;
end

%objects


		deadbug
names {"dead bug","bug"}
title "a dead bug"
descr "A dead bug lies here."
extra {}
"The bug kind of looks like a black lady bug - and it's obviously quite dead. Perhaps someone squashed it. 
You notice the word 'Papi' inscribed with tiny letters on the rim of its shield"
cost 1 SILVER_PIECE
rent 1 IRON_PIECE
type ITEM_OTHER
manipulate {MANIPULATE_TAKE}
weight 0

dilbegin aware unique issue42();
external
   integer skillchecksa@skills(skillidx : integer, abiidx : integer, difficulty : integer);

var
   i : integer;
   ext : extraptr;
code
{
   quit;
   heartbeat := PULSE_SEC;
   :loop:
   wait(SFB_CMD, TRUE);
   ext := self.extra;
   i := skillchecksa@skills(SKI_SEARCH, ABIL_BRA, ext.vals.[1]);
   log(itoa(i));
   goto loop;
}
dilend

/* Program to test if a changed in compiled DIL will reset the recall counter
dilbegin recall unique testbug();
var
   i : integer;
code
{
   quit;
   heartbeat := PULSE_SEC * 4;
   i := rnd(1,10000);

   :loop:
   wait(SFB_TICK, TRUE);
   log("My state is " + itoa(i));
   //log("yay");
   goto loop;

   quit;
}
dilend*/

end


%mobiles


   experiment

names {"experiment"}
title "an experiment"
descr "an experiment is standing here."
weight 1
M_ZOMBIE_SMALL(1,SEX_NEUTRAL)
end

   follower

names {"follower"}
title "a follower"
descr "a follower is standing here."
weight 1
M_ZOMBIE_SMALL(1,SEX_NEUTRAL)
end

   ladybug

names {"lady bug","bug"}
title "a lady bug"
descr "A lady bug is crawling around."
extra {}
"The lady bug kind of looks like a black lady bug. It's alive. And it's crawling around.
You notice the word 'Papi' inscribed with tiny letters on the rim of its shield."
weight 0
M_ZOMBIE_SMALL(1,SEX_NEUTRAL)

dilbegin test001();

var
   u : unitptr;
code
{
   log("test001 begin");
   if (self.outside.symname != "testlabc@test")
   {
      log("test001 fail - wrong start location"); // not in the expected location 
      quit;
   }

   wait(SFB_TICK, TRUE);
   exec("east", self);

   if (self.outside.symname != "testlabe@test")
   {
      log("test001 fail - unable to move east"); // not in the expected location 
      quit;
   }

   wait(SFB_TICK, TRUE);
   exec("west", self);
   if (self.outside.symname != "testlabc@test")
   {
      log("test001 fail - unable to move west"); // not in the expected location 
      quit;
   }

   log("test001 succcess - able to move");
   quit;
}
dilend


/* dilbegin clingontest();
external
   unitptr buglostpc(pc : unitptr);

var
   u : unitptr;
code
{
   :loop:
   wait(SFB_CMD, activator != self);
   u := activator;
   secure(u, lostpc);
   log("Latched onto " + u.name);
   //exec("emote climbs onto " + u.name, self);
   u := buglostpc(u);
   goto loop;

   :lostpc:
   exec("emote lost its host.", self);
   log("Bug lost PC outer loop");
   goto loop;
}
dilend


dilbegin testzonenpcs();
var
   z : zoneptr;
   u : unitptr;
code
{
   z := zhead();

   while (z)
   {
      log(z.name + " " + z.title);

      u := z.npcs;

      if (u)
      {
         log("got an NPC");
         log("Its name is: " + u.symname);
      }

      z := z.next;
   }
   quit;
}
dilend


dilbegin aware unique mytestsymname();
external
   string testsymname();

var
   s1 : string;
   s2 : string;
code
{
   :loop:
   wait(SFB_CMD, activator != self);

   s1 := activator.symname;
   s2 := self.symname;
   exec("say I am "+s2+" and you are "+s1, self);
   exec("say I am "+self.symname+" and you are "+activator.symname, self);
   s1 := "say I am "+self.symname+" and you are "+activator.symname;
   exec(s1, self);
   s1 := "say when calling: act, self, self, act " + activator.symname + testsymname() + self.symname + activator.symname;
   exec(s1, self);
   goto loop;
}
dilend*/
end


/*
dilbegin findsymtest();
var 
   u : unitptr;
   s : string;
   i : integer;
code
{
   heartbeat := PULSE_SEC * 10;
   :loop:
   wait(SFB_CMD, command("burp"));

   log("activator = " + activator.symname + " idx = " + itoa(activator.idx));
   log("self      = " + self.symname + " idx = " + itoa(self.idx));

   if (self.symname == activator.symname)
      log("Symname is identical");

   if (self.idx == activator.idx)
      log("Idx is identical");

   u := findrndunit(self, FIND_UNIT_WORLD, UNIT_ST_NPC);
   s := u.symname;
   i := u.idx;

   log("found " + s + " " + itoa(i));
   pause;

   u := findsymbolic(s, i);
   s := u.symname;
   i := u.idx;

   log("found " + s + " " + itoa(i));
   goto loop;
}
dilend



dilbegin zonetest();
var 
   z : zoneptr;
code
{
   :loop:
   wait(SFB_CMD, command("smile"));
   z := findzone("basis");

   if (z == null)
      log("no such zone");
   else
      log("found zone z = " + z.name);
   goto loop;
}
dilend


dilbegin dispatchtest();
var 
  s : string;
code
{
   :loop:
   wait(SFB_CMD, command("jump"));

   s := "CHANNEL discord @ " + "<discord> @Papi says, 'Hiya'";
   sendtoalldil(s, "channel@function");
   goto loop;
}
dilend

dilbegin shelltest();
var 
  i : integer;
code
{
   :loop:
   wait(SFB_CMD, command("bow"));

   i := shell("test.sh olle golle");
   log("shell = " + itoa(i));
   goto loop;
}
dilend

dilbegin aware comtest();
var
   s : string;
code
{
   heartbeat := PULSE_SEC*4;

   :init:
   wait(SFB_COM, TRUE);

   if (activator.fighting)
      s := activator.fighting.nameidx;
   else
      s := "(null)";

   log("COM message: " + activator.nameidx + " attacking " + s);
   goto init;
   
   quit;
}
dilend

end*/


/* Reset is only performed at boot time */

%reset

load ladybug into testlabc max 1

%end
