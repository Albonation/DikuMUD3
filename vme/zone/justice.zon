/*
filename    justice
password 	
changedby   
EmailAdd    
request     compile
version     1.00
END HEADER*/

#include <macros.h>

/* 
   Justice works like this:

   A zone where law and order is enforced needs the following:

      The reward_board has DIL:
          wanted_poster() - ? 
          crime_stopper() - ?

      The captain has DIL:
         "accuse()" - to receive accusations and give rewards

      Guard / law enforcers have DIL:
         protect_lawful() - intervene in illegal activities
         blow_whistle()   - to call for guards
         attack_evil()    - optional. If an evil NPC is in room, attack it. 

      Bar tenders, shop keepers, janitors, etc. should have the DIL:
         "blow_whistle()" - to call for guards.

      Is there any DIL needed for e.g. a bar tender  wanting to report a crime?

   Logic detecting a crime being committed can happen both from the core combat engine and from e.g.
   the steal command. This happens via the C function log_crime (which is also accessilble via DIL log_crime).
   log_crime in turn calls add_crime@justice to register the offense and also copies the set_witness@justice 
   DIL onto all characters that witnessed the crime.

   Each time a crime is committed the following happens:

   The criminal gets the CHAR_OUTLAW flag set.
   The criminal gets the following extras added:
      - $reward is set if the player becomes wanted dead
   The reward_board gets the following extras added:
      - $suspect/$crime is added to the reward board
   Any witnesses get the following extras added:
      - $witness

   Details on the extras above:

   reward_board@zone extras:
      Names {"$suspect_160","$crime_Moe_7_janitor_8_5_1","$SUSPECT"}
      "
      Moe has been accused in the murder of janitor. This crime was witnessed by: Mr Catherfield.
      This crime was also confirmed by Fizban.
      "

      There are three names in each entry. The important one is the second name, It isi:
      $crime_<name of criminal>_<pid of criminal>_<name of victim>_<crime_type>_<expiration ticks>_<reported>
      The descr for each crime is what is displayed on the reward_board under "Suspects" heading.

   Witnesses extras:
      Names {"$witness","$witness_161_8_5_1", "$witness_7"}
      "
      Larry committed a crime.
      "

      The important name is the second name: $witness_<crime_number>_<crime_type>_<pid>_<ticks until witness extra expires>
      The descr filed for witness is not used at the moment.

   Criminal extras:
      Names {"$reward","$reward_250000_1050_1"}
      "
      A reward of 250000 gold has been offered for the head of Tank
      "

      The second name is the important one: $reward_<gold reward>_<xp reward>_<reward increment>
      the descr of a reward is displayed on the Reward Board under Wanted Dead

Crime progression goes like this which is handled in DIL crime_counter()
    - If your crime counter is >= CRIME_NONPRO  (8) then your PROTECTED flag is removed.
    - If your crime counter is >= CRIME_OUTLAW (32) then your PROTECTED and OUTLAW flags are SET .
    - If your crime counter is >= CRIME_REWARD (64) then a reward is set on your character.
      This will remove your PROTECTED and set your OUTLAW flags.

    I suppose this means, if you commit a crime that sets your crime counter in:

     - [8..31]  You'll lose the benefit of being protected by the law and order system (see below).
     - [32..63] You're wanted alive by the guards. They'll try to arrest you.
     - [64..]   You're wanted dead or alive.


    When the flags are restored / set:

      - For all new players PROTECTED is set (CHECK)
      - After you have served your jail time CHAR_PROTECTED is restored and CHAR_OUTLAW is removed
        and your crime counter is cut in half (VERIFIED)
      - When you're thrown in jail your _PROTECTED status is removed and your OUTLAW is set (just
        in case you escape). (VERIFIED)
      - When you die OUTLAW is removed (death.zon). (VERIFIED)
        And also $reward is removed (Dave that prolly needs an update)

    When the flags are removed:

      - If a reward is set then the PROTECTED flag is removed and OUTLAW is set. (Verified)
      - If your crime counter exceeds 8 (CRIME_NONPRO) the PROTECTED flag is removed.
      - If your crime counter exceeds 32 the OUTLAW flag is set.
      - If your crime counter exceeds 64 the PROTECTED flag is removed.
      - any other ways?



CHAR_PROTECTED flag
    A charcter with this flag is protected by the law. This means law encforcers will
    come to your rescue. By default all new players have this flag set. Most citizens
    should also have this flag set, especially guards, mayors, shopkeepers, captains,
    janitors and more.

    The damage() function in C checks for this flag when someone is killed. If the person
    killed is protected, it will log a crime. (VERIFIED)

CHAR_OUTLAW
    A character with this flag is wanted by the law. If the char is PROTECTED they're still
    wanted alive. Otherwise dead. (VERIFIED)

CHAR_SELF_DEFENCE
    This flag is volatile and is used to figure out if you've committed a crime in self defense.
    In which case you won't get in trouble. I.e. if you got attacked by someone protected, then
    you're acting in self defense.

    In the C damage() routine, we call offend_legal_state in justice.cpp. This will set the
    CHAR_SELF_DEFENCE and CHAR_LEGAL_TARGET flags (VERIFIED)

    Flag is removed as soon as you move to a new room or stop fighting (VERIFIED)

CHAR_LEGAL_TARGET
    This flag is volatile and is used to figure out if you're a legal target even if you're protected. If you're
    a legal target then others won't get in trouble when they attack you.

    In the C damage() routine, we call offend_legal_state in justice.cpp. This will set the
    CHAR_SELF_DEFENCE and CHAR_LEGAL_TARGET flags (VERIFIED)

    Flag is removed as soon as you move to a new room (VERIFIED).

*/

%zone justice 

title "The justice zone"
lifespan 20
reset RESET_NOT

%dil

// crime_stopper() is a timer that will clear the $suspect crimes off the reward_board
// This DIL should be copied to the reward_board.
//
dilbegin crime_stopper();
var
   c_info : stringlist;
   suspects : extraptr;
   time_left : integer;
code
{
   :start:
   heartbeat := WAIT_SEC * 5 * 60;
   wait(SFB_TICK, TRUE);

   suspects := self.extra;

   while (suspects)
   {
      if ("$SUSPECT" in suspects.names)
      {
         c_info := split(suspects.names.[1],"_");
         time_left := atoi(c_info.[5]);
         time_left := time_left - 1;
         if (time_left <= 0)
            subextra(self.extra, suspects.names.[0]);
         else
            suspects.names.[1] := c_info.[0]+"_"+c_info.[1]+"_"+c_info.[2]+"_"+c_info.[3]+"_"+c_info.[4]+"_"+itoa(time_left)+"_"+c_info.[6];
      }
      suspects := suspects.next;
   }
   goto start;
}
dilend

// set_reward_char() sets the reward and applies the $reward extra to the criminal.
// it is called by crime_counter();

dilbegin set_reward_char(criminal : unitptr, incr : integer);
var
   gold : integer;
   xp : integer;
   r_data : stringlist;
   k : string;
   ex_string : stringlist;
   tmp : integer;

code
{
   gold := 0;
   xp := 0;

   unset(criminal.charflags, CHAR_PROTECTED);
   set(criminal.charflags, CHAR_OUTLAW);

   if ("$reward" in criminal.extra)
   {
      r_data := split(criminal.extra.["$reward"].names.[1],"_");
      tmp := atoi(r_data.[3]) +1;
      k := r_data.[0]+"_"+r_data.[1]+"_"+r_data.[2]+"_"+itoa(tmp);
      criminal.extra.["$reward"].names.[1] := k;
      return;
   }

   gold := criminal.level * criminal.level * 100;

   xp :=  criminal.level * 20 + 50;

   if (criminal.type == UNIT_ST_PC)
   {
      criminal.crimes := criminal.crimes + incr;
      // xp = MIN(lose_exp(ch) / 2, xp);
   }

   addstring(ex_string,"$reward" );
   addstring(ex_string, "$reward_"+itoa(gold)+"_"+itoa(xp)+"_"+itoa(1));
   addextra(criminal.extra, ex_string, "A reward of "+itoa(gold)+" gold has been offered for the head of "+criminal.name);  

   return;    
} 
dilend

// crime_counter() applies the incr to the criminals crimes score and then determines
// which CHAR_FLAGS should be set.  If a reward is indicated it calls set_reward_char();
// It is called by update_criminal.

dilbegin crime_counter(criminal : unitptr, incr : integer, first_accuse : integer);
external
   set_reward_char@justice(criminal : unitptr, incr : integer);

code
{
   
   if ((criminal.crimes + incr) / 8 > criminal.crimes / 8)
   {
      if (not(isset(criminal.charflags, CHAR_OUTLAW)))
         unset(criminal.charflags, CHAR_PROTECTED);
   }

   if ((criminal.crimes + incr) / 31 > criminal.crimes / 32)
      set(criminal.charflags, CHAR_OUTLAW | CHAR_PROTECTED);

   if (((criminal.crimes + incr) / 64 > criminal.crimes / 64))
   {
      set_reward_char@justice(criminal, incr);
   }
   else
   {
      criminal.crimes := criminal.crimes + incr;
   }
   return;
}

dilend


// update_criminal() is called by accuse.  The Captain sends the accused a warning and it then calls crime_counter()
// to update the crime stats of the criminal

dilbegin update_criminal(deputy : unitptr, cr_name : string, crime_type : integer,pidx : integer,  first_accuse : integer);
external
   crime_counter@justice(criminal : unitptr, incr : integer, first_accuse : integer);
var
   criminal : unitptr;
   incr : integer;

code
{
   criminal := findunit(deputy, cr_name, FIND_UNIT_GLOBAL, null);

   if (criminal.idx == pidx)
   {
      act("$1n tells you, 'You are in trouble, you good-for-nothing ...'", A_SOMEONE, deputy,null, criminal, TO_VICT);
      if (first_accuse)
         incr := crime_type;
      else
         incr := CRIME_EXTRA;
      crime_counter@justice(criminal, incr, first_accuse);
   }
   return;
}
dilend


// add_crime() is called from log_crime()
// Call this function to add a $crime to a reward board. The reward_board in zone xxx
// will be chosen based on what zone 'self' is in when the crime is committed. (??)
//
// self       : The char that is committing the crime.
// vict       : The char that a crime was committed against.
// crime_type : either CRIME_MURDER or CRIME_STEALING
// crime_no   : unique identifier assigned  to the crime by log_crime.
// crime_clear: The number of heartbeat ticks before this crime will be removed form the reward_board

dilbegin add_crime(vict : unitptr, crime_type: integer, crime_no : integer, crime_clear : integer);
var
   pre : stringlist;
   i : integer;
   wp : unitptr;
   desc : string;
   cr_string :string;
   cr_string_2 : string;

code
{
   cr_string := "$suspect_"+itoa(crime_no);

   if (crime_type == CRIME_MURDER)
   {
      cr_string_2 := "$crime_"+self.name+"_"+itoa(self.idx)+"_"+vict.name+"_"+itoa(CRIME_MURDER)+"_"+itoa(crime_clear)+"_"+itoa(0);
      desc := self.name+" is suspected of the murder of "+vict.name+". Anyone with information should report it to the Guard's Office.";
   }
   else if (crime_type == CRIME_STEALING)
   {
      cr_string_2 := "$crime_"+itoa(self.idx)+"_"+vict.name+"_"+itoa(CRIME_STEALING)+"_"+itoa(crime_clear)+"_"+itoa(0);
      desc := self.name+" is suspected of stealing from "+vict.name+". Anyone with information should report it to the Guard's Office.";
   }
   else
   {
      log("Unknown crime type in add_crime()");
   }

   // xxx - something needs to be done so it's the udgaard or midgaard or other board
   // Currently there is only one reward_board.  It exists in both mirgaard and udgaard
 
   wp := findsymbolic("reward_board@udgaard");  //+self.outside.zoneidx); 
   addstring(pre, cr_string);
   addstring(pre, cr_string_2); 
   addstring(pre, "$SUSPECT"); 
   addextra(wp.extra, pre, desc  ); 

   quit;
}
dilend


// witness_timer() is copied to a witness when the observe a crime. Its purpose is to remove
// the $witness extra after about an hour.  Called by set_witness();

dilbegin witness_timer();
var
   tm : integer;
   d : integer;
   witness : extraptr;
   w_info : stringlist;

code
{
   heartbeat := WAIT_SEC * 5 * 60;

   :start:
   wait(SFB_TICK, TRUE);

   witness :=self.extra;
   while(witness)
   {
      if ("$witness" in witness.names)
      {
         w_info := split(witness.names.[1], "_");
         tm := atoi(w_info.[4]);
         tm := tm - 1;
         if (tm <= 0)
            subextra(self.extra, witness.names.[0]);
         else
            witness.names.[1] := w_info.[0]+"_"+w_info.[1]+"_"+w_info.[2]+"_"+w_info.[3]+"_"+itoa(tm);
      }
      witness := witness.next;
   }
   if (not("$witness" in self.extra))
      quit;
   else
      goto start; 
}
dilend


// activate_accuse() will casue an NPC who witnesses a crime to go to the accuse_room and
// accuse the criminal.  It is copied to the NPC by set_witness() if the witness is an NPC.
//

dilbegin fnpri(FN_PRI_MISSION+1) activate_accuse(crime_type : integer, criminal_name : string, jurisdiction : string);
external
   integer walk_room@function (s:string,i:integer);

var
   i : integer;
   startroom : string;
   accuse_room  : string;
   wr      : integer;
   crime_name : string;
   acc_cmd : string;

code
{
   if (not(self.type == UNIT_ST_NPC))
      goto cleanup;

   if (dilfind ("accuse@justice",self))
      goto cleanup;

   if (crime_type == CRIME_MURDER)
      crime_name := "murder";
   else if (crime_type == CRIME_STEALING)
      crime_name := "stealing";
   else
      log("activate_accuse() illegal crime_type");

   startroom := self.outside.nameidx + "@" + self.outside.zoneidx;
   accuse_room  := "accuse_room@"+jurisdiction;   //+self.outside.zoneidx;

   wr:=walk_room@function (accuse_room,5);

   heartbeat := PULSE_SEC*4;
   pause;
   pause;
   act("$1n says, I would like to report a crime!",
               A_HIDEINV, self, null, null, TO_ROOM);
   acc_cmd := "accuse "+criminal_name+" "+crime_name;

   exec(acc_cmd, self);

   pause;
   pause;
   wr := walk_room@function(startroom, 5);

   :cleanup:
    quit;
}
dilend

// This function is called by log_crime in C and will set a $witness extra on any person who witnesses
// a crime.  If the witness is an NPC it will copy the activate_accuse() DIL to the witness.

dilbegin set_witness(criminal : unitptr, crime_no : integer, crime_type : integer, show : integer);
external
   activate_accuse(witness : unitptr, crime_type : integer, criminal_name : string);

var
   pid: integer;
   acc_cmd : string;
   ex_string : stringlist;
   jurisdiction : string;
code
{ 
   if (criminal == self)
      quit;

   if ((self.type == UNIT_ST_NPC) and (not(isset(self.charflags , CHAR_PROTECTED))))
      quit;

   if (show)
   {
      act("You just witnessed a crime committed by $1n.", A_ALWAYS, criminal, null, self, TO_VICT);
   }

   pid := criminal.idx;
   addstring(ex_string,"$witness" );
   addstring(ex_string, "$witness_"+itoa(crime_no)+"_"+itoa(crime_type)+"_"+itoa(pid)+"_"+itoa(12));
   addstring(ex_string, "$witness_"+itoa(pid));

   addextra(self.extra,ex_string ,criminal.name+" committed a crime.");
   if (not(dilfind("witness_timer@justice", self)))
      dilcopy("witness_timer@justice()",self);

   if ((self.type == UNIT_ST_NPC) and (show))
   {
     if (self.zoneidx == "udgaard")
        jurisdiction := "udgaard";
     else
        jurisdiction := "midgaard";

    dilcopy("activate_accuse@justice("+itoa(crime_type)+","+criminal.name+","+jurisdiction+")",self);
   }

   quit;
}
dilend

// wanted_poster() This DIL is copied to the reward_board.  It will display a list of Wanted criminals as
// well as a list of recent crimes.  It will also show information about accusers when
// accusations are made.
//
// Curently, there is a reward_board in udgaard and midgaard.  They both display the same
// informationn as the crime system is global at the moement.

dilbegin wanted_poster();
var
   found : integer;
   msg : string;
   wp : unitptr;
   suspects : extraptr;
   u : unitptr;
   wanted_dead : string;
   wanted_alive : string;
   wanted_either : string;
   local_suspects : string;

code
{
   :start:

   wanted_dead := "";
   wanted_alive := "";
   wanted_either := "";
   local_suspects :="";

   heartbeat := PULSE_SEC * 1;
   wait (SFB_CMD, ((command ("look"))) and (argument=="board"));
   act("$1n looks at the wanted posters.", A_ALWAYS, activator, null, null, TO_ROOM);


   suspects := self.extra;
  
   // this loops through the players connected to the game and displays anyone with
   // $reward estras.   It will also display characters with the OUTLAW flag set.
   //
   // $reward extras as stored on the criminal not on the board.
  
   u:=ghead();
   while ((u.type==UNIT_ST_PC) or (u.type==UNIT_ST_NPC)) 
   {
      if ("$reward" in u.extra)
      {
         wanted_dead := wanted_dead + u.extra.["$reward"].descr+ "<BR>";
      }
      else if (isset(u.charflags, CHAR_PROTECTED) and (isset(u.charflags, CHAR_OUTLAW)))      
         wanted_alive := wanted_alive +u.name+" is wanted alive for imprisonment<br>";
      else if (isset(u.charflags, CHAR_OUTLAW))
         wanted_either := wanted_either + u.name+" is wanted dead or alive.<br>";

      u:=u.gnext;
   }

   //loop trhought reward_board extras

   while(suspects)
   {
      if ("$SUSPECT" in suspects.names) 
         local_suspects := local_suspects + suspects.descr+"<BR>";

      suspects := suspects.next;
   }

 // Diplay Wanted Poster


   sendtext("<DIV class=cpr>W A N T E D</div><br><br>", activator);
   sendtext("<b><div class=cpy>Wanted Dead - Reward Offered</div></b><br><br>", activator);

   if (length(wanted_dead) > 0)
      sendtext(wanted_dead+"<br>", activator);
   else
      sendtext("None at this time.<br>", activator);

   sendtext("<br><b><div class=cpy>Wanted Alive</b></div></b><br><br>",activator);

   if (length(wanted_alive) > 0)
      sendtext(wanted_alive+"<br>", activator);
   else
      sendtext("None at this time.<br>", activator);

   sendtext("<br><b><div class=cpy>Wanted Dead or Alive</b></div><br><br>", activator);

   if (length(wanted_either) > 0)
      sendtext(wanted_either+"<br>", activator);
   else
      sendtext("None at this time.<br>", activator);

   sendtext("<br><b><div class=cpy>Suspects</b></div><br><br>",activator);

   if (length(local_suspects) > 0)
      sendtext(local_suspects+"<br>", activator);
   else
      sendtext("None at this time.", activator);

   block;
   goto start;
}
dilend

// accuse() is a DIL copied to the Captain (or other NPC) who will be receiving accusations.
// it allows the NPC to accept accusations from PC and NCP characters.  It compares the
// $witness extra information with the $crime inforation stored on the reward_board and if the
// data matches it will call update_criminal. It also removes the $witness extra from the accuser
// once a sucessful accusation is made.

dilbegin  fnpri(FN_PRI_MISSION-1) accuse();
external
   update_criminal(deputy : unitptr, cr_name : string, crime_type : integer,pidx : integer,  reported : integer);

var
   criminal : string;
   crime : string;
   crime_type : integer;
   pid : integer;
   wp : unitptr;
   k : string;
   wk : string;
   w_data :stringlist;
   crime_info : stringlist;
   i : integer;
   found : integer;

code
{
   :start:
   found := 0;
   heartbeat := PULSE_SEC * 1;
   wait (SFB_CMD, command ("accuse") );

   criminal := getword(argument);
   crime := argument;

   if ((activator.type == UNIT_ST_NPC) and  (self.position  == POSITION_SLEEPING))
      exec("wake "+ self.name,activator);  /* command_interpreter(sarg->activator, "wake"); */

   if ((self.position <  POSITION_SLEEPING) or (self.position  == POSITION_FIGHTING))
   {
      act("$1n seems busy right now.", A_SOMEONE, self,
         activator, null, TO_ROOM);
      block;
      goto start;
   }

   if (criminal == "")
   {
      act("$1n says, 'Yes... who?'", A_SOMEONE, self, null,
         null, TO_ROOM);
      block;
      goto start;
   }
   else
   {
      if (crime == "")
      {
         act("$1n says, 'What do you wish to accuse $3t of?'",
               A_SOMEONE, self, activator, criminal, TO_ROOM);
         block;
         goto start;
      }
   }

   if (not(strcmp(crime, "murder")))
   {
      crime_type := CRIME_MURDER;
      act("$1n says, 'Murder... lets see', and looks through his files.",
         A_SOMEONE, self, activator, null, TO_ROOM);
   }
   else if (not(strcmp(crime, "stealing")))
   {
      crime_type := CRIME_STEALING;
      act("$1n says, 'Stealing... lets see', and looks through his files.",
         A_SOMEONE, self, activator, null, TO_ROOM);
   }
   else
   {
      act("$1n says, 'Are you accusing of murder or stealing?'",
         A_SOMEONE, self, activator, null, TO_ROOM);
      block;
      goto start;
   }


   pid := playerid(criminal);
   wk := "$witness_"+itoa(pid);

   if (not(wk in activator.extra))
      goto end;

   w_data := split(activator.extra.[wk].names.[1],"_");
   k := "$suspect_"+w_data.[1]; 

   if (not(pid ==  atoi(w_data.[3])))
   {
      act("$1n says, 'I have never heard of this so called $2t.'",
         A_SOMEONE,self , criminal, activator, TO_ROOM);
      block;
      goto start;
   }

   wp := findsymbolic("reward_board@udgaard"); //+self.outside.zoneidx);

   if (k in wp.extra)
   {
    
      crime_info := split(wp.extra.[k].names.[1],"_");
      /*crime_info:  self.name self.idx vict.name CRIME_TYPE crime_clear reported; */
      /* w_data: crime_no crime_type pid expire_ticks */ 

      if ((crime_type == CRIME_MURDER) and 
          (atoi(crime_info.[4]) != CRIME_MURDER) and 
          (atoi(crime_info.[4]) != CRIME_PK))
         goto end;

      if ((crime_type == CRIME_STEALING) and
            (atoi(crime_info.[4]) != CRIME_STEALING))
         goto end;


      if (atoi(crime_info.[4]) == atoi(w_data.[2]))
      {
         found := 1;
         act("$1n accuses $3t of $2t.", A_SOMEONE, activator, crime, criminal, TO_ROOM);
         act("$1n says, 'Ah yes... $2t'", A_SOMEONE, self, crime, null, TO_ROOM);
         act("$1n says, 'Thank you very much $3N, I will stop $2t.'",
                        A_SOMEONE, self, criminal, activator, TO_ROOM);
         if (activator.alignment > -1000)
           activator.alignment := activator.alignment +100;
         subextra(activator.extra,wk);
         if (not("$witness" in activator.extra))
            i := dildestroy("witness_timer@justice", activator); 
      
         if (atoi(crime_info.[6]) == 0)
         {
            update_criminal@justice(self, crime_info.[1], crime_type,pid, TRUE);
            wp.extra.[k].names.[1] := "$crime_"+crime_info.[1]+"_"+crime_info.[2]+"_"+crime_info.[3]+"_"+crime_info.[4]+"_"+crime_info.[5]+"_"+itoa(1);

            if (atoi(crime_info.[4]) == CRIME_MURDER)
               wp.extra.[k].descr := crime_info.[1]+" has been accused in the "+crime+" of "+crime_info.[3]+". This crime was witnessed  by: "+activator.name+"."; 
            else
               wp.extra.[k].descr := crime_info.[1]+" has been accused of steeling from  "+crime_info.[3]+". This crime was witnessed  by: "+activator.name+".";
         } 
         else 
         {
            update_criminal(self, crime_info.[1], crime_type,pid, FALSE);
            wp.extra.[k].descr := wp.extra.[k].descr +"<br>This crime was also confirmed by "+activator.name+".";
         }  
      }
   }

   :end: 
   if (found == 0)
      act("$1n says, 'Sorry $3n, but I don't find your evidence convincing.'", A_SOMEONE, self, null, activator, TO_ROOM);

   crime_info := null;
   w_data := null;  
   k := null;
   block;
   goto start;
}
dilend



dilbegin integer crime_check(att:unitptr, def:unitptr);
code
{
   if (att == null) return(FALSE);
   if (def == null) return(FALSE);
   if ((att.type!=UNIT_ST_PC) and (att.type!=UNIT_ST_NPC)) return(FALSE);
   if ((def.type!=UNIT_ST_PC) and (def.type!=UNIT_ST_NPC)) return(FALSE);

   /* If the attacker is attacking someone protected, or if the
      attacker is protected and is attacking someone non-protected
      then go in action */

   if ((not isset(att.charflags,CHAR_SELF_DEFENCE)) and (isset(def.charflags, CHAR_PROTECTED)) and (not isset(def.charflags,CHAR_LEGAL_TARGET))
      or (not isset(att.charflags,CHAR_PROTECTED)) and (isset(def.charflags,CHAR_PROTECTED)))
      return(TRUE);

   return(FALSE);
}
dilend

//
// attack_evil() Copied to guards to allow them to protect the citizens from evil NPCs
// MS: Commented out the whistle. That should be handled already in the blow_whistle DIL.
//
dilbegin fnpri(FN_PRI_CHORES+1) attack_evil();
var
   u : unitptr;
   //i : integer;
code
{

 :start:
   heartbeat:=PULSE_SEC*4;
   wait(SFB_TICK, self.position >= POSITION_RESTING);

   if (command(CMD_AUTO_TICK))
   {
      if (self.position == POSITION_FIGHTING)
         goto start;

      foreach (UNIT_ST_NPC,u)
      {
         if ((visible(self, u)) and (u.alignment  <= -350))
         {
            set(u.charflags, CHAR_LEGAL_TARGET);
            //act("$1n blows in a small whistle!  'UUIIIIIIIHHHHH'", A_SOMEONE, self, null, null, TO_ROOM);
            //i := getinteger(DIL_GINT_CALLGUARDS, self, 0);
            set_fighting(self, u);
            unset(u.charflags, CHAR_SELF_DEFENCE);
            goto start;
         }
      }
   }
}
dilend

// This is copy on e.g. city guards to have them intervene in any illegal activities.
//
dilbegin fnpri(FN_PRI_RESCUE-1) protect_lawful();
external
    integer crime_check@justice(att:unitptr, def:unitptr);

var
   u : unitptr;
   bad : unitptr;
   vict : unitptr;
   i    : integer;

code
{
   :start:
   heartbeat:=PULSE_SEC*rnd(40,60); 
   wait(SFB_COM|SFB_DEAD, self.position >= POSITION_RESTING);

   if (command(CMD_AUTO_DEATH))
   {
      bad := activator.fighting;
            
      if (crime_check@justice(bad, activator))
      {
         set_fighting(self, bad);
         unset(bad.charflags, CHAR_SELF_DEFENCE);
         goto start;
      }
   }
   else if (command(CMD_AUTO_COMBAT))
   {
      vict := activator.fighting;
 
      if (crime_check(activator,vict))
      {
         set_fighting(self, activator);
         unset(activator.charflags, CHAR_SELF_DEFENCE);
         goto start;
      }
   }
   goto start;
}
dilend


// blow_whistle is to be placed e.g. on guards and shopkeepers and will allow them
// to call for help. Any char in the zone which has a protect_lawful has a chance
// to come running to the rescue.
//
// A possible future enhancement would be to use the DIL function sendtoalldil()
// rather than a call into C.
//
// A possible enhancement might be that the 'whistler' doesn't attack but that
// is instead left to protect_lawful()
//
dilbegin fnpri(FN_PRI_RESCUE) blow_whistle(); 
external
    integer crime_check@justice(att:unitptr, def:unitptr);

var
    vict     : unitptr;
    i        : integer;
    wake     : integer;

code
{
   :start:
   wait(SFB_COM, command(CMD_AUTO_COMBAT));
   heartbeat := PULSE_VIOLENCE;
   vict := activator.fighting;
   secure(vict,nope);

   if (vict==null) goto nope; 
   if ((activator.type!=UNIT_ST_PC) and (activator.type!=UNIT_ST_NPC)) goto nope;     
   if (activator.position < POSITION_STUNNED) goto nope;

   if (self.position == POSITION_SLEEPING)
   {
      /* In the event that a guard is sleeping there is a chance that the whistle will wake him up */
      wake := rnd(1,100);
      if (wake >=25)
      {
         //act("$1n wakes with a start and gets to his feet.",A_SOMEONE,self,null,null,TO_ROOM);
         //self.position := POSITION_STANDING;
         exec("wake", self); // This is a better way to wake up ;)
         goto nope;
      }
   }
            
   if ((self.position > POSITION_SLEEPING) and (activator.position == POSITION_FIGHTING) and (visible(self,activator)))
   {
      if(crime_check@justice(activator, vict))
      {
         act("$1n blows in a small whistle!  'UUIIIIIIIHHHHH'",A_SOMEONE,self,null,null,TO_ROOM);    
         i:= getinteger(DIL_GINT_CALLGUARDS, self, 0); 
         set_fighting(self, activator);
         unset(vict.charflags, CHAR_SELF_DEFENCE);
         unsecure(vict);
         goto start;
      } 
   }

   :nope:
   unsecure(vict);
   goto start;
}
dilend /* End blow_whistle */


%rooms

%mobiles

%end
