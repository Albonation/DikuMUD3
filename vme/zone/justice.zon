/*
filename    justice
password 	
changedby   
EmailAdd    
request     compile
version     1.00
END HEADER*/

#include <macros.h>

/* 
   Justice works like this:

   A zone where law and order is enforced needs the following:

      The reward_board has DIL:
          wanted_poster() - ? 
          crime_stopper() - ?

      The captain has DIL:
         "accuse()" - to receive accusations and give rewards

      Guard / law enforcers have DIL:
         protect_lawful() - intervene in illegal activities
         blow_whistle()   - to call for guards
         attack_evil()    - optional. If an evil NPC is in room, attack it. 

      Bar tenders, shop keepers, janitors, etc. should have the DIL:
         "blow_whistle()" - to call for guards.

      Is there any DIL needed for e.g. a bar tender  wanting to report a crime?

   Logic detecting a crime being committed can happen both from the core combat engine and from e.g.
   the steal command. This happens via the C function log_crime (which is also accessilble via DIL log_crime).
   log_crime in turn calls add_crime@justice to register the offense and also copies the set_witness@justice 
   DIL onto all characters that witnessed the crime.

   Each time a crime is committed the following happens:

   The criminal gets the CHAR_OUTLAW flag set.
   The criminal gets the following extras added:
      - $reward is set if the player becomes wanted dead
   The reward_board gets the following extras added:
      - $crime is added to the reward board
   Any witnesses get the following extras added:
      - $witness

   Details on the extras above:

   reward_board@zone extras:
      
      There are 9 names in each crime extrathree names in each entry. 
      They are as follows:
 
       Crime Extra Names:

       names.[0] $crime contant
       names.[1] $crime_CRIME_SERIAL_NO
       names.[2] $crime_$crime_CRIMINAL_NAME
       names.[3] $crime_CRIMINAL_PID
       names.[4] $crime_CRIME_TYPE
       names.[5] $crime_VICTIM_NAME
       names.[6] $crime_TICK UNTIL REMOVED FROM LIST
       names.[7] $crime_is_NPC (Y or N)
       names.[8] $crime_CRIME_REPORTED 1 or 0

      The descr for each crime is what is displayed on the reward_board under "Suspects" heading.

   Witnesses extras:
   
There are 6 names on each witness extra.  THey are as follows:
 
   Witness Data Elements:
      
        names.[0] $witness
        names.[1] $witness_CRIMINAL NAME
        names.[2] $witness_CRIME_SERIAL_NO
        names.[3] $witness_CRIME_TYPE
        names.[4] $witness_PLAYERID
        names.[5] $witness_TICKS UNTIL REMOVED

      The important name is the second name: $witness_<crime_nddumber>_<crime_type>_<pid>_<ticks until witness extra expires>
      The descr filed for witness is not used at the moment.

   Criminal extras:
     

   Names {"$reward","$reward_250000_1050_1"}
      "
      A reward of 250000 gold has been offered for the head of Tank
      "

      The second name is the important one: $reward_<gold reward>_<xp reward>_<reward increment>
      the descr of a reward is displayed on the Reward Board under Wanted Dead
      
Crime progression goes like this which is handled in DIL crime_counter()
    - If your crime counter is >= CRIME_NONPRO  (8) then your PROTECTED flag is removed.
    - If your crime counter is >= CRIME_OUTLAW (32) then your PROTECTED and OUTLAW flags are SET .
    - If your crime counter is >= CRIME_REWARD (64) then a reward is set on your character.
      This will remove your PROTECTED and set your OUTLAW flags.

    I suppose this means, if you commit a crime that sets your crime counter in:

     - [8..31]  You'll lose the benefit of being protected by the law and order system (see below).
     - [32..63] You're wanted alive by the guards. They'll try to arrest you.
     - [64..]   You're wanted dead or alive.


    When the flags are restored / set:

      - For all new players PROTECTED is set (CHECK)
      - After you have served your jail time CHAR_PROTECTED is restored and CHAR_OUTLAW is removed
        and your crime counter is cut in half (VERIFIED)
      - When you're thrown in jail your _PROTECTED status is removed and your OUTLAW is set (just
        in case you escape). (VERIFIED)
      - When you die OUTLAW is removed (death.zon). (VERIFIED)
        And also $reward is removed (Dave that prolly needs an update)

    When the flags are removed:

      - If a reward is set then the PROTECTED flag is removed and OUTLAW is set. (Verified)
      - If your crime counter exceeds 8 (CRIME_NONPRO) the PROTECTED flag is removed.
      - If your crime counter exceeds 32 the OUTLAW flag is set.
      - If your crime counter exceeds 64 the PROTECTED flag is removed.
      - any other ways?



CHAR_PROTECTED flag
    A charcter with this flag is protected by the law. This means law encforcers will
    come to your rescue. By default all new players have this flag set. Most citizens
    should also have this flag set, especially guards, mayors, shopkeepers, captains,
    janitors and more.

    The damage() function in C checks for this flag when someone is killed. If the person
    killed is protected, it will log a crime. (VERIFIED)

CHAR_OUTLAW
    A character with this flag is wanted by the law. If the char is PROTECTED they're still
    wanted alive. Otherwise dead. (VERIFIED)

CHAR_SELF_DEFENCE
    This flag is volatile and is used to figure out if you've committed a crime in self defense.
    In which case you won't get in trouble. I.e. if you got attacked by someone protected, then
    you're acting in self defense.

    In the C damage() routine, we call offend_legal_state in justice.cpp. This will set the
    CHAR_SELF_DEFENCE and CHAR_LEGAL_TARGET flags (VERIFIED)

    Flag is removed as soon as you move to a new room or stop fighting (VERIFIED)

CHAR_LEGAL_TARGET
    This flag is volatile and is used to figure out if you're a legal target even if you're protected. If you're
    a legal target then others won't get in trouble when they attack you.

    In the C damage() routine, we call offend_legal_state in justice.cpp. This will set the
    CHAR_SELF_DEFENCE and CHAR_LEGAL_TARGET flags (VERIFIED)

    Flag is removed as soon as you move to a new room (VERIFIED).

*/

%zone justice 

title "The justice zone"
lifespan 20
reset RESET_NOT

%dil


// crime_stopper() is a timer that will clear the $suspect crimes off the reward_board
// This DIL should be copied to the reward_board.
//

/*
 Crime Info Data Elements:
        [0] $crime
        [1] $crime_CRIME_SERIAL_NO
        [2] $crime_$crime_CRIMINAL_NAME
        [3] $crime_CRIMINAL_PID
        [4] $crime_CRIME_TYPE
        [5] $crime_VICTIM_NAME
        [6] $crime_TICK UNTIL REMOVED FROM LIST
        [7] $crime_is_NPC (Y or N)     
        [8] $crime_CRIME_REPORTED 1 or 0
*/

dilbegin crime_stopper();
var
   c_info : stringlist;
   suspects : extraptr;
   time_left : integer;
code
{
   :start:
   heartbeat := WAIT_SEC * 5 * 60;
   wait(SFB_TICK, TRUE);

   suspects := "$crime" in self.extra;

   while (suspects)
   {
         c_info := split(suspects.names.[6],"_");
         time_left := atoi(c_info.[1]);
         time_left := time_left - 1;
         if (time_left <= 0)
            subextra(self.extra, suspects.names.[1]);
         else
            suspects.names.[6] := "$crime_"+itoa(time_left);
      suspects := suspects.next;
   }
   goto start;
}
dilend



// set_reward_char() sets the reward and applies the $reward extra to the criminal.
// it is called by crime_counter();
//
dilbegin set_reward_char(criminal : unitptr, incr : integer);
var
   gold : integer;
   xp : integer;
   r_data : stringlist;
   k : string;
   ex_string : stringlist;
   tmp : integer;

code
{
   gold := 0;
   xp := 0;

   unset(criminal.charflags, CHAR_PROTECTED);
   set(criminal.charflags, CHAR_OUTLAW);

   if ("$reward" in criminal.extra)
   {
      r_data := split(criminal.extra.["$reward"].names.[1],"_");
      tmp := atoi(r_data.[3]) +1;
      k := r_data.[0]+"_"+r_data.[1]+"_"+r_data.[2]+"_"+itoa(tmp);
      criminal.extra.["$reward"].names.[1] := k;
      return;
   }

   gold := criminal.level * criminal.level * 100;
    if (gold > PLATINUM_MULT)
       gold := PLATINUM_MULT;  // Make sure this doesn't become more than 1 PP

   xp :=  criminal.level * 20 + 50;
   if (xp > 1000)
       xp := 1000;  // Make sure some glitch doesn't cause excessive XP

   if (criminal.type == UNIT_ST_PC)
      criminal.crimes := criminal.crimes + incr;

   addstring(ex_string,"$reward" );
   addstring(ex_string, "$reward_"+itoa(gold)+"_"+itoa(xp)+"_"+itoa(1));
   addextra(criminal.extra, ex_string, "A reward of "+itoa(gold)+" gold has been offered for the head of "+criminal.name);  

   return;    
} 
dilend



// crime_counter() applies the incr to the criminals crimes score and then determines
// which CHAR_FLAGS should be set.  If a reward is indicated it calls set_reward_char();
// It is called by update_criminal.
//
dilbegin crime_counter(criminal : unitptr, incr : integer, first_accuse : integer);
external
   set_reward_char@justice(criminal : unitptr, incr : integer);

code
{
   
 if ((criminal.crimes + incr) / 8 > criminal.crimes / 8)
   {
      if (not(isset(criminal.charflags, CHAR_OUTLAW)))
         unset(criminal.charflags, CHAR_PROTECTED);
   }

   if ((criminal.crimes + incr) / 31 > criminal.crimes / 32)
      set(criminal.charflags, CHAR_OUTLAW | CHAR_PROTECTED);

   if (((criminal.crimes + incr) / 64 > criminal.crimes / 64))
   {
      set_reward_char@justice(criminal, incr);
   }
   else
   {
      criminal.crimes := criminal.crimes + incr;
   }
   return;
}

dilend



// update_criminal() is called by accuse.  The Captain sends the accused a warning and it then calls crime_counter()
// to update the crime stats of the criminal
//
dilbegin update_criminal(deputy : unitptr, cr_name : string, crime_type : integer,pidx : integer,  first_accuse : integer);
external
   crime_counter@justice(criminal : unitptr, incr : integer, first_accuse : integer);
   set_reward_char(criminal : unitptr, incr : integer);
var
   criminal : unitptr;
   incr : integer;

code
{
   criminal := findunit(deputy, cr_name, FIND_UNIT_GLOBAL, null);
   if((criminal.type == UNIT_ST_NPC) and (crime_type == CRIME_MURDER))
   {
      set_reward_char@justice(criminal, 8); 
      return;
   }
   if(criminal.type == UNIT_ST_NPC)
   {
     set(criminal.charflags, CHAR_OUTLAW | CHAR_PROTECTED);
     return;
   }

   
if(criminal.idx == pidx)
   {
      act("$1n tells you, 'You are in trouble, you good-for-nothing ...'", A_SOMEONE, deputy,null, criminal, TO_VICT);
      if (first_accuse)
         incr := crime_type;
      else
         incr := CRIME_EXTRA;
      crime_counter@justice(criminal, incr, first_accuse);
   }
   return;
}
dilend



// add_crime() is called from log_crime()
// Call this function to add a $crime to a reward board. The reward_board in zone xxx
// will be chosen based on what zone 'self' is in when the crime is committed. (??)
//
// self       : The char that is committing the crime.
// vict       : The char that a crime was committed against.
// crime_type : either CRIME_MURDER or CRIME_STEALING
// crime_no   : unique identifier assigned  to the crime by log_crime.
// crime_clear: The number of heartbeat ticks before this crime will be removed form the reward_board
//
dilbegin add_crime(vict : unitptr, crime_type: integer, crime_no : integer, crime_clear : integer);
var
   i : integer;
   wp : unitptr;
   desc : string;
   cr_string : string;
   crime_list : stringlist;
   is_npc : string;
code
{
  
  cr_string := "$crime_"+itoa(crime_no);

   if (crime_type == CRIME_MURDER)
   {
      desc := self.name+" is suspected of the murder of "+vict.name+". Anyone with information should report it to the Guard's Office.";
   }
   else if (crime_type == CRIME_STEALING)
   {
      desc := self.name+" is suspected of stealing from "+vict.name+". Anyone with information should report it to the Guard's Office.";
   }
   else
   {
      log("Unknown crime type in add_crime()");
   }

   // xxx - something needs to be done so it's the udgaard or midgaard or other board
   // Currently there is only one reward_board.  It exists in both mirgaard and udgaard
   if (self.type == UNIT_ST_NPC)
      is_npc := "Y";
   else
      is_npc := "N";
 
   wp := findsymbolic("reward_board@udgaard");  //+self.outside.zoneidx); 
   addstring(crime_list, "$crime");
   addstring(crime_list, cr_string);
   addstring(crime_list, "$crime_"+self.name);
   addstring(crime_list, "$crime_"+itoa(self.idx));
   addstring(crime_list, "$crime_"+itoa(crime_type));
   addstring(crime_list, "$crime_"+vict.name);
   addstring(crime_list, "$crime_"+itoa(crime_clear));
   addstring(crime_list, "$crime_"+is_npc);
   addstring(crime_list, "$crime_"+itoa(0));
    
   addextra(wp.extra, crime_list, desc); 

   quit;
}
dilend



// witness_timer() is copied to a witness when the observe a crime. Its purpose is to remove
// the $witness extra after about an hour.  Called by set_witness();
//

/*  Witness Data Elements:
        [0] $witness
        [1] $witness_CRIMINAL NAME
        [2] $witness_CRIME_SERIAL_NO
        [3] $witness_CRIME_TYPE
        [4] $witness_PLAYERID
        [5] $witness_TICKS UNTIL REMOVED
*/
dilbegin witness_timer();
var
   tm : integer;
   d : integer;
   witness : extraptr;
   w_info : stringlist;

code
{
   heartbeat := WAIT_SEC * 5 * 60;

   :start:
   wait(SFB_TICK, TRUE);

   witness := "$witness" in self.extra;
   while(witness)
   {
         w_info := split(witness.names.[5], "_");
         tm := atoi(w_info.[1]);
         tm := tm - 1;
         if (tm <= 0)
            subextra(self.extra, witness.names.[2]);
         else
            witness.names.[5] := "$witness_"+itoa(tm);
      witness := witness.next;
   }
   if (not("$witness" in self.extra))
      quit;
   else
      goto start; 
}
dilend

// activate_accuse() will casue an NPC who witnesses a crime to go to the accuse_room and
// accuse the criminal.  It is copied to the NPC by set_witness() if the witness is an NPC.
//
dilbegin fnpri(FN_PRI_MISSION+1) activate_accuse(crime_type : integer, criminal_name : string, jurisdiction : string);
external
   integer walk_room@function (s:string,i:integer);

var
   i : integer;
   startroom : string;
   accuse_room  : string;
   wr      : integer;
   crime_name : string;
   acc_cmd : string;

code
{
   if (not(self.type == UNIT_ST_NPC))
      goto cleanup;

   // The captain himself shouldn't get an activate_accuse()
   if (dilfind("accuse@justice",self))
      goto cleanup;

   if (crime_type == CRIME_MURDER)
      crime_name := "murder";
   else if (crime_type == CRIME_STEALING)
      crime_name := "stealing";
   else
      log("activate_accuse() illegal crime_type");

   startroom := self.outside.nameidx + "@" + self.outside.zoneidx;
   accuse_room  := "accuse_room@"+jurisdiction;   //+self.outside.zoneidx;

   // Let this mission critical DIL take priority over lower level chores.
   priority;

   wr := walk_room@function(accuse_room, 5);

   heartbeat := PULSE_SEC*4;
   pause;
   pause;
   act("$1n says, I would like to report a crime!",
               A_HIDEINV, self, null, null, TO_ROOM);
   acc_cmd := "accuse "+criminal_name+" "+crime_name;

   exec(acc_cmd, self);

   pause;
   pause;
   wr := walk_room@function(startroom, 5);

   :cleanup:
    quit;
}
dilend


// Find the jurisdiction for 'self'. It's either Udgaard or Midgaard right now. 
// Expand this function if you have more jurisdictions (zones with justice)
//
dilbegin string get_juris();
var
   s : string;
   rm : unitptr;

code
{
   s := "midgaard"; // Default

   rm := self.outside;

   while (rm.type != UNIT_ST_ROOM)
      rm := rm.outside;

   if (rm.zoneidx == "udgaard")
      s := "udgaard";   
   else if (self.zoneidx == "udgaard")
      s := "udgaard";   

   return(s);
}
dilend



// This function is called by log_crime in C and will set a $witness extra on any person who witnesses
// a crime.  If the witness is an NPC it will copy the activate_accuse() DIL to the witness.
//
dilbegin set_witness(criminal : unitptr, crime_no : integer, crime_type : integer, show : integer);
external
   activate_accuse(witness : unitptr, crime_type : integer, criminal_name : string);
   string get_juris@justice();
var
   pid: integer;
   acc_cmd : string;
   ex_string : stringlist;
   jurisdiction : string;
code
{ 
   if (criminal == self)
      quit;

   if ((self.type == UNIT_ST_NPC) and (not(isset(self.charflags , CHAR_PROTECTED))))
      quit;

   if (show)
   {
      act("You just witnessed a crime committed by $1n.", A_ALWAYS, criminal, null, self, TO_VICT);
   }

   pid := criminal.idx;
   addstring(ex_string,"$witness" );
   addstring(ex_string,"$witness_"+criminal.name);
   addstring(ex_string,"$witness_"+itoa(crime_no));
   addstring(ex_string,"$witness_"+itoa(crime_type));
   addstring(ex_string,"$witness_"+itoa(pid));
   addstring(ex_string,"$witness_"+itoa(12));

   addextra(self.extra,ex_string ,criminal.name+" committed a crime.");
   if (not(dilfind("witness_timer@justice", self)))
      dilcopy("witness_timer@justice()",self);

   if ((self.type == UNIT_ST_NPC) and (show))
   {
    jurisdiction := get_juris@justice();
    dilcopy("activate_accuse@justice("+itoa(crime_type)+","+criminal.name+","+jurisdiction+")",self);
   }

   quit;
}
dilend



// wanted_poster() This DIL is copied to the reward_board.  It will display a list of Wanted criminals as
// well as a list of recent crimes.  It will also show information about accusers when
// accusations are made.
//
// Curently, there is a reward_board in udgaard and midgaard.  They both display the same
// informationn as the crime system is global at the moement.
//
dilbegin wanted_poster();
var
   found : integer;
   msg : string;
   wp : unitptr;
   suspects : extraptr;
   u : unitptr;
   wanted_dead : string;
   wanted_alive : string;
   wanted_either : string;
   local_suspects : string;

code
{
   :start:

   wanted_dead := "";
   wanted_alive := "";
   wanted_either := "";
   local_suspects :="";

   heartbeat := PULSE_SEC * 1;
   wait (SFB_CMD, ((command ("look"))) and (argument=="board"));
   act("$1n looks at the wanted posters.", A_ALWAYS, activator, null, null, TO_ROOM);


   suspects := self.extra;
  
   // this loops through the players connected to the game and displays anyone with
   // $reward estras.   It will also display characters with the OUTLAW flag set.
   //
   // $reward extras as stored on the criminal not on the board.
  
   u:=ghead();
   while ((u.type==UNIT_ST_PC) or (u.type==UNIT_ST_NPC)) 
   {
      if ("$reward" in u.extra)
      {
         wanted_dead := wanted_dead + u.extra.["$reward"].descr+ "<BR>";
      }
      else if (isset(u.charflags, CHAR_PROTECTED) and (isset(u.charflags, CHAR_OUTLAW)))      
         wanted_alive := wanted_alive +u.name+" is wanted alive for imprisonment<br>";
      else if (isset(u.charflags, CHAR_OUTLAW))
         wanted_either := wanted_either + u.name+" is wanted dead or alive.<br>";

      u:=u.gnext;
   }

   //loop trhought reward_board extras

   while(suspects)
   {
      if ("$crime" in suspects.names) 
         local_suspects := local_suspects + suspects.descr+"<BR>";

      suspects := suspects.next;
   }

 // Diplay Wanted Poster


   sendtext("<DIV class=cpr>W A N T E D</div><br><br>", activator);
   sendtext("<b><div class=cpy>Wanted Dead - Reward Offered</div></b><br><br>", activator);

   if (length(wanted_dead) > 0)
      sendtext(wanted_dead+"<br>", activator);
   else
      sendtext("None at this time.<br>", activator);

   sendtext("<br><b><div class=cpy>Wanted Alive</b></div></b><br><br>",activator);

   if (length(wanted_alive) > 0)
      sendtext(wanted_alive+"<br>", activator);
   else
      sendtext("None at this time.<br>", activator);

   sendtext("<br><b><div class=cpy>Wanted Dead or Alive</b></div><br><br>", activator);

   if (length(wanted_either) > 0)
      sendtext(wanted_either+"<br>", activator);
   else
      sendtext("None at this time.<br>", activator);

   sendtext("<br><b><div class=cpy>Suspects</b></div><br><br>",activator);

   if (length(local_suspects) > 0)
      sendtext(local_suspects+"<br>", activator);
   else
      sendtext("None at this time.", activator);

   block;
   goto start;
}
dilend



// accuse() is a DIL copied to the Captain (or other NPC) who will be receiving accusations.
// it allows the NPC to accept accusations from PC and NCP characters.  It compares the
// $witness extra information with the $crime inforation stored on the reward_board and if the
// data matches it will call update_criminal. It also removes the $witness extra from the accuser
// once a sucessful accusation is made.
//

/*
        Crime Info Data Elements:
        [0] $crime
        [1] $crime_CRIME_SERIAL_NO
        [2] $crime_$crime_CRIMINAL_NAME
        [3] $crime_CRIMINAL_PID
        [4] $crime_CRIME_TYPE
        [5] $crime_VICTIM_NAME
        [6] $crime_TICK UNTIL REMOVED FROM LIST
        [7] $crime_is_NPC (Y or N)     i
        [8] $crime_CRIME_REPORTED 1 or 0

       Witness Data Elements:
        [0] $witness
        [1] $witness_CRIMINAL NAME
        [2] $witness_CRIME_SERIAL_NO
        [3] $witness_CRIME_TYPE
        [4] $witness_PLAYERID
        [5] $witness_TICKS UNTIL REMOVED
*/

dilbegin  fnpri(FN_PRI_MISSION-1) accuse();
external
   update_criminal(deputy : unitptr, cr_name : string, crime_type : integer,pidx : integer,  reported : integer);

var
   args :stringlist;
   arg_count : integer;
   criminal : string;
   crime_type : integer;
   crime : string;
   wp : unitptr;
   k : string;
   k2 : string;
   w_data :stringlist;
   i : integer;
   found : integer;
   wk : string;
   ck : string;
   w_ptr : extraptr;
   c_ptr : extraptr;
   w_type : stringlist;
   c_name : stringlist;
   c_pid : stringlist;
   c_type : stringlist;
   c_v_name : stringlist;
   c_reported : stringlist;
   c_is_npc   : stringlist;
code
{
   :start:
   found := 0;
   heartbeat := PULSE_SEC * 1;
   wait (SFB_CMD, command ("accuse") );
  
// this is to deal with NPCs thathave spaces in their names 
   args := getwords(argument);
   criminal := args.[0];
   arg_count := 1;
   while (arg_count < length(args) -1)
   {
    criminal := criminal +" "+ args.[arg_count];
    arg_count := arg_count +1;
   }
  
   crime := args.[length(args)-1];

   if ((activator.type == UNIT_ST_NPC) and  (self.position  == POSITION_SLEEPING))
      exec("wake "+ self.name, activator);  /* command_interpreter(sarg->activator, "wake"); */

   if ((self.position <  POSITION_SLEEPING) or (self.position  == POSITION_FIGHTING))
   {
      act("$1n seems busy right now.", A_SOMEONE, self,
         activator, null, TO_ROOM);
      block;
      goto start;
   }
   if (criminal == "")
   {
      act("$1n says, 'Yes... who?'", A_SOMEONE, self, null,
         null, TO_ROOM);
      block;
      goto start;
   }
   else
   {
      if (crime == "")
      {
         act("$1n says, 'What do you wish to accuse $3t of?'",
               A_SOMEONE, self, activator, criminal, TO_ROOM);
         block;
         goto start;
      }
   }

   if (not(strcmp(crime, "murder")))
   {
      crime_type := CRIME_MURDER;
      act("$1n says, 'Murder... lets see', and looks through his files.",
         A_SOMEONE, self, activator, null, TO_ROOM);
   }
   else if (not(strcmp(crime, "stealing")))
   {
      crime_type := CRIME_STEALING;
      act("$1n says, 'Stealing... lets see', and looks through his files.",
         A_SOMEONE, self, activator, null, TO_ROOM);
   }
   else
   {
      act("$1n says, 'Are you accusing of murder or stealing?'",
         A_SOMEONE, self, activator, null, TO_ROOM);
      block;
      goto start;
   }

   wp := findsymbolic("reward_board@udgaard");
   wk := "$witness_"+criminal;
   ck := "$crime_"+criminal;

   w_ptr := wk in activator.extra;
   c_ptr := ck in wp.extra;

     if (not(w_ptr) or not(c_ptr))
        goto end;
     
   w_data := split(w_ptr.names.[2],"_");
   k := "$crime_"+w_data.[1];
   k2 := w_ptr.names.[2];
   if (k in c_ptr)
   {
      w_type := split(w_ptr.[k2].names.[3], "_");
      c_name := split(c_ptr.[k].names.[2], "_");
      c_pid := split(c_ptr.[k].names.[3], "_");
      c_type := split(c_ptr.[k].names.[4],"_"); 
      c_v_name := split(c_ptr.[k].names.[5], "_"); 
      c_is_npc := split(c_ptr.[k].names.[7], "_");
      c_reported := split(c_ptr.[k].names.[8], "_");
      
      if ((crime_type == CRIME_MURDER) and
          (atoi(c_type.[1]) != CRIME_MURDER) and
          (atoi(c_type.[1]) != CRIME_PK))
         goto end;

       if ((crime_type == CRIME_STEALING) and
            (atoi(c_type.[1]) != CRIME_STEALING))
         goto end;
     
       if (atoi(c_type.[1]) == atoi(w_type.[1]))
      {
         found := 1;
         act("$1n accuses $3t of $2t.", A_SOMEONE, activator, crime, criminal, TO_ROOM);
         act("$1n says, 'Ah yes... $2t'", A_SOMEONE, self, crime, null, TO_ROOM);
         act("$1n says, 'Thank you very much $3N, I will stop $2t.'",
                        A_SOMEONE, self, criminal, activator, TO_ROOM);
         if (activator.alignment > -1000)
           activator.alignment := activator.alignment +100;
         subextra(activator.extra,k2);
         if (not("$witness" in activator.extra))
            i := dildestroy("witness_timer@justice", activator);

         if (atoi(c_reported.[1]) == 0)
         {
            update_criminal@justice(self, c_name.[1], crime_type, atoi(c_pid.[1]), TRUE);
             c_ptr.[k].names.[8] := itoa(1);
            if (atoi(c_type.[1]) == CRIME_MURDER)
               c_ptr.[k].descr := c_name.[1]+" has been accused in the "+crime+" of "+c_v_name.[1]+". This crime was witnessed  by: "+activator.name+".";
            else
                c_ptr.[k].descr := c_name.[1]+" has been accused of "+crime+" from "+c_v_name.[1]+". This crime was witnessed  by: "+activator.name+".";
         }
         else
         {
            update_criminal(self, c_name.[1], crime_type, atoi(c_pid.[1]), FALSE);
            c_ptr.[k].descr := wp.extra.[k].descr +"<br>This crime was also confirmed by "+activator.name+".";
         }
      }


     }

   :end: 
   if (found == 0)
      act("$1n says, 'Sorry $3n, but I don't find your evidence convincing.'", A_SOMEONE, self, null, activator, TO_ROOM);

   block;
   goto start;
}
dilend



dilbegin integer crime_check(att:unitptr, def:unitptr);
code
{
   if (att == null) return(FALSE);
   if (def == null) return(FALSE);
   if ((att.type!=UNIT_ST_PC) and (att.type!=UNIT_ST_NPC)) return(FALSE);
   if ((def.type!=UNIT_ST_PC) and (def.type!=UNIT_ST_NPC)) return(FALSE);

   /* If the attacker is attacking someone protected, or if the
      attacker is protected and is attacking someone non-protected
      then go in action */

   if ((not isset(att.charflags,CHAR_SELF_DEFENCE)) and (isset(def.charflags, CHAR_PROTECTED)) and (not isset(def.charflags,CHAR_LEGAL_TARGET))
      or (not isset(att.charflags,CHAR_PROTECTED)) and (isset(def.charflags,CHAR_PROTECTED)))
      return(TRUE);

   return(FALSE);
}
dilend



// attack_evil() Copied to guards to allow them to protect the citizens from evil NPCs
// MS: Commented out the whistle. That should be handled already in the blow_whistle DIL.
//
dilbegin fnpri(FN_PRI_CHORES+1) attack_evil();
var
   u : unitptr;
   //i : integer;
code
{
   heartbeat:=PULSE_SEC*4;

:start:
   wait(SFB_TICK, self.position >= POSITION_RESTING);

   if (self.position == POSITION_FIGHTING)
      goto start;

   if (command(CMD_AUTO_TICK))
   {
      foreach (UNIT_ST_NPC,u)
      {
         if (visible(self, u) and (u.alignment  <= -350))
         {
            set(u.charflags, CHAR_LEGAL_TARGET);
            act("$1n says, 'Begone you evil cretin!'", A_SOMEONE, self, null, null, TO_ROOM);
            //i := getinteger(DIL_GINT_CALLGUARDS, self, 0);
            set_fighting(self, u);
            unset(u.charflags, CHAR_SELF_DEFENCE);
         }
      }
   }

   goto start;
}
dilend



// This is copy on e.g. city guards to have them intervene in any illegal activities.
//
dilbegin fnpri(FN_PRI_RESCUE-1) protect_lawful();
external
    integer crime_check@justice(att:unitptr, def:unitptr);

var
   u : unitptr;
   bad : unitptr;
   vict : unitptr;
   i    : integer;

code
{
   :start:
   heartbeat:=PULSE_SEC*rnd(40,60); 
   wait(SFB_COM|SFB_DEAD, self.position >= POSITION_RESTING);

   if (command(CMD_AUTO_DEATH))
   {
      bad := activator.fighting;
            
      if (crime_check@justice(bad, activator))
      {
         set_fighting(self, bad);
         unset(bad.charflags, CHAR_SELF_DEFENCE);
         goto start;
      }
   }
   else if (command(CMD_AUTO_COMBAT))
   {
      vict := activator.fighting;
 
      if (crime_check(activator,vict))
      {
         set_fighting(self, activator);
         unset(activator.charflags, CHAR_SELF_DEFENCE);
         goto start;
      }
   }
   goto start;
}
dilend


// Listen for a whistle...
// This DIL gets triggered by any blowwhistle anywhere in the world. Will come
// aid anyone in the juris list if self is also in jurislist. 
//
// juris : work in progress. The list of zones the NPC will assist in. ??[] = all??
// The message received is "WHISTLE roomzone roomname" and is the destination room
//
dilbegin aware unique fnpri(FN_PRI_MISSION) whistlisten(juris : stringlist);
external
   to_the_rescue@midgaard(sroomto : string);

var
   u : unitptr;
   s : string;
code
{
   :listen:
   wait(SFB_MSG, ("WHISTLE " in argument)); // Wait for a whistle

   // Only 1/6th chance to react
   if (rnd(1,6) != 1)
      goto listen;

   // Only react if self is in one of the available jurisdictions
   if (not (self.zoneidx in juris))
      goto listen;

   s := getword(argument); // Skip "WHISTLE "
   s := getword(argument);

   // If the room is not in my juris, skip
   if (not (s in juris))
      goto listen;

   s := argument+"@"+s;
   to_the_rescue@midgaard(s);

   goto listen;
}
dilend



// blow_whistle is to be placed e.g. on guards and shopkeepers and will allow them
// to call for help. Any char in the zone which has a protect_lawful has a chance
// to come running to the rescue.
//
// A possible future enhancement would be to use the DIL function sendtoalldil()
// rather than a call into C.
//
// A possible enhancement might be that the 'whistler' doesn't attack but that
// is instead left to protect_lawful()
//
dilbegin fnpri(FN_PRI_RESCUE) blow_whistle(); 
external
    integer crime_check@justice(att:unitptr, def:unitptr);

var
    vict     : unitptr;
    i        : integer;
    wake     : integer;
    rm       : unitptr;
code
{
   :start:
   wait(SFB_COM, command(CMD_AUTO_COMBAT));
   heartbeat := PULSE_VIOLENCE;
   vict := activator.fighting;
   secure(vict,nope);

   if (vict==null) goto nope; 
   if ((activator.type!=UNIT_ST_PC) and (activator.type!=UNIT_ST_NPC)) goto nope;     
   if (activator.position < POSITION_STUNNED) goto nope;

   if (self.position == POSITION_SLEEPING)
   {
      /* In the event that a guard is sleeping there is a chance that the combat will wake him up */
      wake := rnd(1,100);
      if (wake >=25)
      {
         exec("wake", self); // This is a better way to wake up ;)
         goto nope;
      }
   }
            
   if ((self.position > POSITION_SLEEPING) and (activator.position == POSITION_FIGHTING) and (visible(self,activator)))
   {
      if(crime_check@justice(activator, vict))
      {
         act("$1n blows in a small whistle!  'UUIIIIIIIHHHHH'",A_SOMEONE,self,null,null,TO_ROOM);    
         
         rm := self.outside;
         while (rm.type != UNIT_ST_ROOM)
            rm := rm.outside;
         sendtoalldil("WHISTLE "+rm.zoneidx+" "+rm.nameidx, "whistlisten@justice");

         // i:= getinteger(DIL_GINT_CALLGUARDS, self, 0); 
         set_fighting(self, activator);
         unset(vict.charflags, CHAR_SELF_DEFENCE);
         unsecure(vict);
         goto start;
      } 
   }

   :nope:
   unsecure(vict);
   goto start;
}
dilend /* End blow_whistle */


%rooms

%mobiles
                           weakling

names {"weakling"}
title "a weakling"
descr "A small weakling is standing here."
extra {} "It looks incredibly fragile."
ability[ABIL_STR]  100
ability[ABIL_DEX]  0
ability[ABIL_CON]  0
ability[ABIL_HP]   0
ability[ABIL_BRA]  0
ability[ABIL_MAG]  0
ability[ABIL_DIV]  0
ability[ABIL_CHA]  0

romflags {CHAR_PROTECTED}
end

%end
